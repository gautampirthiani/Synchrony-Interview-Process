{"ast":null,"code":"var Buffer = require('buffer/').Buffer;\nvar hashUtils = require('./browserHashUtils');\nvar BLOCK_SIZE = 64;\nvar DIGEST_LENGTH = 20;\nvar KEY = new Uint32Array([0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0]);\nvar INIT = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\nvar MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1;\n\n/**\n * @api private\n */\nfunction Sha1() {\n  this.h0 = 0x67452301;\n  this.h1 = 0xEFCDAB89;\n  this.h2 = 0x98BADCFE;\n  this.h3 = 0x10325476;\n  this.h4 = 0xC3D2E1F0;\n  // The first 64 bytes (16 words) is the data chunk\n  this.block = new Uint32Array(80);\n  this.offset = 0;\n  this.shift = 24;\n  this.totalLength = 0;\n}\n\n/**\n * @api private\n */\nmodule.exports = exports = Sha1;\nSha1.BLOCK_SIZE = BLOCK_SIZE;\nSha1.prototype.update = function (data) {\n  if (this.finished) {\n    throw new Error('Attempted to update an already finished hash.');\n  }\n  if (hashUtils.isEmptyData(data)) {\n    return this;\n  }\n  data = hashUtils.convertToBuffer(data);\n  var length = data.length;\n  this.totalLength += length * 8;\n  for (var i = 0; i < length; i++) {\n    this.write(data[i]);\n  }\n  return this;\n};\nSha1.prototype.write = function write(byte) {\n  this.block[this.offset] |= (byte & 0xff) << this.shift;\n  if (this.shift) {\n    this.shift -= 8;\n  } else {\n    this.offset++;\n    this.shift = 24;\n  }\n  if (this.offset === 16) this.processBlock();\n};\nSha1.prototype.digest = function (encoding) {\n  // Pad\n  this.write(0x80);\n  if (this.offset > 14 || this.offset === 14 && this.shift < 24) {\n    this.processBlock();\n  }\n  this.offset = 14;\n  this.shift = 24;\n\n  // 64-bit length big-endian\n  this.write(0x00); // numbers this big aren't accurate in javascript anyway\n  this.write(0x00); // ..So just hard-code to zero.\n  this.write(this.totalLength > 0xffffffffff ? this.totalLength / 0x10000000000 : 0x00);\n  this.write(this.totalLength > 0xffffffff ? this.totalLength / 0x100000000 : 0x00);\n  for (var s = 24; s >= 0; s -= 8) {\n    this.write(this.totalLength >> s);\n  }\n  // The value in state is little-endian rather than big-endian, so flip\n  // each word into a new Uint8Array\n  var out = new Buffer(DIGEST_LENGTH);\n  var outView = new DataView(out.buffer);\n  outView.setUint32(0, this.h0, false);\n  outView.setUint32(4, this.h1, false);\n  outView.setUint32(8, this.h2, false);\n  outView.setUint32(12, this.h3, false);\n  outView.setUint32(16, this.h4, false);\n  return encoding ? out.toString(encoding) : out;\n};\nSha1.prototype.processBlock = function processBlock() {\n  // Extend the sixteen 32-bit words into eighty 32-bit words:\n  for (var i = 16; i < 80; i++) {\n    var w = this.block[i - 3] ^ this.block[i - 8] ^ this.block[i - 14] ^ this.block[i - 16];\n    this.block[i] = w << 1 | w >>> 31;\n  }\n\n  // Initialize hash value for this chunk:\n  var a = this.h0;\n  var b = this.h1;\n  var c = this.h2;\n  var d = this.h3;\n  var e = this.h4;\n  var f, k;\n\n  // Main loop:\n  for (i = 0; i < 80; i++) {\n    if (i < 20) {\n      f = d ^ b & (c ^ d);\n      k = 0x5A827999;\n    } else if (i < 40) {\n      f = b ^ c ^ d;\n      k = 0x6ED9EBA1;\n    } else if (i < 60) {\n      f = b & c | d & (b | c);\n      k = 0x8F1BBCDC;\n    } else {\n      f = b ^ c ^ d;\n      k = 0xCA62C1D6;\n    }\n    var temp = (a << 5 | a >>> 27) + f + e + k + (this.block[i] | 0);\n    e = d;\n    d = c;\n    c = b << 30 | b >>> 2;\n    b = a;\n    a = temp;\n  }\n\n  // Add this chunk's hash to result so far:\n  this.h0 = this.h0 + a | 0;\n  this.h1 = this.h1 + b | 0;\n  this.h2 = this.h2 + c | 0;\n  this.h3 = this.h3 + d | 0;\n  this.h4 = this.h4 + e | 0;\n\n  // The block is now reusable.\n  this.offset = 0;\n  for (i = 0; i < 16; i++) {\n    this.block[i] = 0;\n  }\n};","map":{"version":3,"names":["Buffer","require","hashUtils","BLOCK_SIZE","DIGEST_LENGTH","KEY","Uint32Array","INIT","MAX_HASHABLE_LENGTH","Math","pow","Sha1","h0","h1","h2","h3","h4","block","offset","shift","totalLength","module","exports","prototype","update","data","finished","Error","isEmptyData","convertToBuffer","length","i","write","byte","processBlock","digest","encoding","s","out","outView","DataView","buffer","setUint32","toString","w","a","b","c","d","e","f","k","temp"],"sources":["/Users/damianmiskow/Desktop/Projects/Synchrony-Interview-Process/node_modules/aws-sdk/lib/browserSha1.js"],"sourcesContent":["var Buffer = require('buffer/').Buffer;\nvar hashUtils = require('./browserHashUtils');\n\nvar BLOCK_SIZE = 64;\n\nvar DIGEST_LENGTH = 20;\n\nvar KEY = new Uint32Array([\n    0x5a827999,\n    0x6ed9eba1,\n    0x8f1bbcdc | 0,\n    0xca62c1d6 | 0\n]);\n\nvar INIT = [\n    0x6a09e667,\n    0xbb67ae85,\n    0x3c6ef372,\n    0xa54ff53a,\n    0x510e527f,\n    0x9b05688c,\n    0x1f83d9ab,\n    0x5be0cd19,\n];\n\nvar MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1;\n\n/**\n * @api private\n */\nfunction Sha1() {\n    this.h0 = 0x67452301;\n    this.h1 = 0xEFCDAB89;\n    this.h2 = 0x98BADCFE;\n    this.h3 = 0x10325476;\n    this.h4 = 0xC3D2E1F0;\n    // The first 64 bytes (16 words) is the data chunk\n    this.block = new Uint32Array(80);\n    this.offset = 0;\n    this.shift = 24;\n    this.totalLength = 0;\n}\n\n/**\n * @api private\n */\nmodule.exports = exports = Sha1;\n\nSha1.BLOCK_SIZE = BLOCK_SIZE;\n\nSha1.prototype.update = function (data) {\n    if (this.finished) {\n        throw new Error('Attempted to update an already finished hash.');\n    }\n\n    if (hashUtils.isEmptyData(data)) {\n        return this;\n    }\n\n    data = hashUtils.convertToBuffer(data);\n\n    var length = data.length;\n    this.totalLength += length * 8;\n    for (var i = 0; i < length; i++) {\n        this.write(data[i]);\n    }\n\n    return this;\n};\n\nSha1.prototype.write = function write(byte) {\n    this.block[this.offset] |= (byte & 0xff) << this.shift;\n    if (this.shift) {\n        this.shift -= 8;\n    } else {\n        this.offset++;\n        this.shift = 24;\n    }\n\n    if (this.offset === 16) this.processBlock();\n};\n\nSha1.prototype.digest = function (encoding) {\n    // Pad\n    this.write(0x80);\n    if (this.offset > 14 || (this.offset === 14 && this.shift < 24)) {\n      this.processBlock();\n    }\n    this.offset = 14;\n    this.shift = 24;\n\n    // 64-bit length big-endian\n    this.write(0x00); // numbers this big aren't accurate in javascript anyway\n    this.write(0x00); // ..So just hard-code to zero.\n    this.write(this.totalLength > 0xffffffffff ? this.totalLength / 0x10000000000 : 0x00);\n    this.write(this.totalLength > 0xffffffff ? this.totalLength / 0x100000000 : 0x00);\n    for (var s = 24; s >= 0; s -= 8) {\n        this.write(this.totalLength >> s);\n    }\n    // The value in state is little-endian rather than big-endian, so flip\n    // each word into a new Uint8Array\n    var out = new Buffer(DIGEST_LENGTH);\n    var outView = new DataView(out.buffer);\n    outView.setUint32(0, this.h0, false);\n    outView.setUint32(4, this.h1, false);\n    outView.setUint32(8, this.h2, false);\n    outView.setUint32(12, this.h3, false);\n    outView.setUint32(16, this.h4, false);\n\n    return encoding ? out.toString(encoding) : out;\n};\n\nSha1.prototype.processBlock = function processBlock() {\n    // Extend the sixteen 32-bit words into eighty 32-bit words:\n    for (var i = 16; i < 80; i++) {\n      var w = this.block[i - 3] ^ this.block[i - 8] ^ this.block[i - 14] ^ this.block[i - 16];\n      this.block[i] = (w << 1) | (w >>> 31);\n    }\n\n    // Initialize hash value for this chunk:\n    var a = this.h0;\n    var b = this.h1;\n    var c = this.h2;\n    var d = this.h3;\n    var e = this.h4;\n    var f, k;\n\n    // Main loop:\n    for (i = 0; i < 80; i++) {\n      if (i < 20) {\n        f = d ^ (b & (c ^ d));\n        k = 0x5A827999;\n      }\n      else if (i < 40) {\n        f = b ^ c ^ d;\n        k = 0x6ED9EBA1;\n      }\n      else if (i < 60) {\n        f = (b & c) | (d & (b | c));\n        k = 0x8F1BBCDC;\n      }\n      else {\n        f = b ^ c ^ d;\n        k = 0xCA62C1D6;\n      }\n      var temp = (a << 5 | a >>> 27) + f + e + k + (this.block[i]|0);\n      e = d;\n      d = c;\n      c = (b << 30 | b >>> 2);\n      b = a;\n      a = temp;\n    }\n\n    // Add this chunk's hash to result so far:\n    this.h0 = (this.h0 + a) | 0;\n    this.h1 = (this.h1 + b) | 0;\n    this.h2 = (this.h2 + c) | 0;\n    this.h3 = (this.h3 + d) | 0;\n    this.h4 = (this.h4 + e) | 0;\n\n    // The block is now reusable.\n    this.offset = 0;\n    for (i = 0; i < 16; i++) {\n        this.block[i] = 0;\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}