{"ast":null,"code":"var AWS = require('../core'),\n  url = AWS.util.url,\n  crypto = AWS.util.crypto.lib,\n  base64Encode = AWS.util.base64.encode,\n  inherit = AWS.util.inherit;\nvar queryEncode = function (string) {\n  var replacements = {\n    '+': '-',\n    '=': '_',\n    '/': '~'\n  };\n  return string.replace(/[\\+=\\/]/g, function (match) {\n    return replacements[match];\n  });\n};\nvar signPolicy = function (policy, privateKey) {\n  var sign = crypto.createSign('RSA-SHA1');\n  sign.write(policy);\n  return queryEncode(sign.sign(privateKey, 'base64'));\n};\nvar signWithCannedPolicy = function (url, expires, keyPairId, privateKey) {\n  var policy = JSON.stringify({\n    Statement: [{\n      Resource: url,\n      Condition: {\n        DateLessThan: {\n          'AWS:EpochTime': expires\n        }\n      }\n    }]\n  });\n  return {\n    Expires: expires,\n    'Key-Pair-Id': keyPairId,\n    Signature: signPolicy(policy.toString(), privateKey)\n  };\n};\nvar signWithCustomPolicy = function (policy, keyPairId, privateKey) {\n  policy = policy.replace(/\\s/mg, '');\n  return {\n    Policy: queryEncode(base64Encode(policy)),\n    'Key-Pair-Id': keyPairId,\n    Signature: signPolicy(policy, privateKey)\n  };\n};\nvar determineScheme = function (url) {\n  var parts = url.split('://');\n  if (parts.length < 2) {\n    throw new Error('Invalid URL.');\n  }\n  return parts[0].replace('*', '');\n};\nvar getRtmpUrl = function (rtmpUrl) {\n  var parsed = url.parse(rtmpUrl);\n  return parsed.path.replace(/^\\//, '') + (parsed.hash || '');\n};\nvar getResource = function (url) {\n  switch (determineScheme(url)) {\n    case 'http':\n    case 'https':\n      return url;\n    case 'rtmp':\n      return getRtmpUrl(url);\n    default:\n      throw new Error('Invalid URI scheme. Scheme must be one of' + ' http, https, or rtmp');\n  }\n};\nvar handleError = function (err, callback) {\n  if (!callback || typeof callback !== 'function') {\n    throw err;\n  }\n  callback(err);\n};\nvar handleSuccess = function (result, callback) {\n  if (!callback || typeof callback !== 'function') {\n    return result;\n  }\n  callback(null, result);\n};\nAWS.CloudFront.Signer = inherit({\n  /**\n   * A signer object can be used to generate signed URLs and cookies for granting\n   * access to content on restricted CloudFront distributions.\n   *\n   * @see http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html\n   *\n   * @param keyPairId [String]    (Required) The ID of the CloudFront key pair\n   *                              being used.\n   * @param privateKey [String]   (Required) A private key in RSA format.\n   */\n  constructor: function Signer(keyPairId, privateKey) {\n    if (keyPairId === void 0 || privateKey === void 0) {\n      throw new Error('A key pair ID and private key are required');\n    }\n    this.keyPairId = keyPairId;\n    this.privateKey = privateKey;\n  },\n  /**\n   * Create a signed Amazon CloudFront Cookie.\n   *\n   * @param options [Object]            The options to create a signed cookie.\n   * @option options url [String]     The URL to which the signature will grant\n   *                                  access. Required unless you pass in a full\n   *                                  policy.\n   * @option options expires [Number] A Unix UTC timestamp indicating when the\n   *                                  signature should expire. Required unless you\n   *                                  pass in a full policy.\n   * @option options policy [String]  A CloudFront JSON policy. Required unless\n   *                                  you pass in a url and an expiry time.\n   *\n   * @param cb [Function] if a callback is provided, this function will\n   *   pass the hash as the second parameter (after the error parameter) to\n   *   the callback function.\n   *\n   * @return [Object] if called synchronously (with no callback), returns the\n   *   signed cookie parameters.\n   * @return [null] nothing is returned if a callback is provided.\n   */\n  getSignedCookie: function (options, cb) {\n    var signatureHash = 'policy' in options ? signWithCustomPolicy(options.policy, this.keyPairId, this.privateKey) : signWithCannedPolicy(options.url, options.expires, this.keyPairId, this.privateKey);\n    var cookieHash = {};\n    for (var key in signatureHash) {\n      if (Object.prototype.hasOwnProperty.call(signatureHash, key)) {\n        cookieHash['CloudFront-' + key] = signatureHash[key];\n      }\n    }\n    return handleSuccess(cookieHash, cb);\n  },\n  /**\n   * Create a signed Amazon CloudFront URL.\n   *\n   * Keep in mind that URLs meant for use in media/flash players may have\n   * different requirements for URL formats (e.g. some require that the\n   * extension be removed, some require the file name to be prefixed\n   * - mp4:<path>, some require you to add \"/cfx/st\" into your URL).\n   *\n   * @param options [Object]          The options to create a signed URL.\n   * @option options url [String]     The URL to which the signature will grant\n   *                                  access. Any query params included with\n   *                                  the URL should be encoded. Required.\n   * @option options expires [Number] A Unix UTC timestamp indicating when the\n   *                                  signature should expire. Required unless you\n   *                                  pass in a full policy.\n   * @option options policy [String]  A CloudFront JSON policy. Required unless\n   *                                  you pass in a url and an expiry time.\n   *\n   * @param cb [Function] if a callback is provided, this function will\n   *   pass the URL as the second parameter (after the error parameter) to\n   *   the callback function.\n   *\n   * @return [String] if called synchronously (with no callback), returns the\n   *   signed URL.\n   * @return [null] nothing is returned if a callback is provided.\n   */\n  getSignedUrl: function (options, cb) {\n    try {\n      var resource = getResource(options.url);\n    } catch (err) {\n      return handleError(err, cb);\n    }\n    var parsedUrl = url.parse(options.url, true),\n      signatureHash = Object.prototype.hasOwnProperty.call(options, 'policy') ? signWithCustomPolicy(options.policy, this.keyPairId, this.privateKey) : signWithCannedPolicy(resource, options.expires, this.keyPairId, this.privateKey);\n    parsedUrl.search = null;\n    for (var key in signatureHash) {\n      if (Object.prototype.hasOwnProperty.call(signatureHash, key)) {\n        parsedUrl.query[key] = signatureHash[key];\n      }\n    }\n    try {\n      var signedUrl = determineScheme(options.url) === 'rtmp' ? getRtmpUrl(url.format(parsedUrl)) : url.format(parsedUrl);\n    } catch (err) {\n      return handleError(err, cb);\n    }\n    return handleSuccess(signedUrl, cb);\n  }\n});\n\n/**\n * @api private\n */\nmodule.exports = AWS.CloudFront.Signer;","map":{"version":3,"names":["AWS","require","url","util","crypto","lib","base64Encode","base64","encode","inherit","queryEncode","string","replacements","replace","match","signPolicy","policy","privateKey","sign","createSign","write","signWithCannedPolicy","expires","keyPairId","JSON","stringify","Statement","Resource","Condition","DateLessThan","Expires","Signature","toString","signWithCustomPolicy","Policy","determineScheme","parts","split","length","Error","getRtmpUrl","rtmpUrl","parsed","parse","path","hash","getResource","handleError","err","callback","handleSuccess","result","CloudFront","Signer","constructor","getSignedCookie","options","cb","signatureHash","cookieHash","key","Object","prototype","hasOwnProperty","call","getSignedUrl","resource","parsedUrl","search","query","signedUrl","format","module","exports"],"sources":["/Users/damianmiskow/Desktop/Projects/Synchrony-Interview-Process/node_modules/aws-sdk/lib/cloudfront/signer.js"],"sourcesContent":["var AWS = require('../core'),\n    url = AWS.util.url,\n    crypto = AWS.util.crypto.lib,\n    base64Encode = AWS.util.base64.encode,\n    inherit = AWS.util.inherit;\n\nvar queryEncode = function (string) {\n    var replacements = {\n        '+': '-',\n        '=': '_',\n        '/': '~'\n    };\n    return string.replace(/[\\+=\\/]/g, function (match) {\n        return replacements[match];\n    });\n};\n\nvar signPolicy = function (policy, privateKey) {\n    var sign = crypto.createSign('RSA-SHA1');\n    sign.write(policy);\n    return queryEncode(sign.sign(privateKey, 'base64'));\n};\n\nvar signWithCannedPolicy = function (url, expires, keyPairId, privateKey) {\n    var policy = JSON.stringify({\n        Statement: [\n            {\n                Resource: url,\n                Condition: { DateLessThan: { 'AWS:EpochTime': expires } }\n            }\n        ]\n    });\n\n    return {\n        Expires: expires,\n        'Key-Pair-Id': keyPairId,\n        Signature: signPolicy(policy.toString(), privateKey)\n    };\n};\n\nvar signWithCustomPolicy = function (policy, keyPairId, privateKey) {\n    policy = policy.replace(/\\s/mg, '');\n\n    return {\n        Policy: queryEncode(base64Encode(policy)),\n        'Key-Pair-Id': keyPairId,\n        Signature: signPolicy(policy, privateKey)\n    };\n};\n\nvar determineScheme = function (url) {\n    var parts = url.split('://');\n    if (parts.length < 2) {\n        throw new Error('Invalid URL.');\n    }\n\n    return parts[0].replace('*', '');\n};\n\nvar getRtmpUrl = function (rtmpUrl) {\n    var parsed = url.parse(rtmpUrl);\n    return parsed.path.replace(/^\\//, '') + (parsed.hash || '');\n};\n\nvar getResource = function (url) {\n    switch (determineScheme(url)) {\n        case 'http':\n        case 'https':\n            return url;\n        case 'rtmp':\n            return getRtmpUrl(url);\n        default:\n            throw new Error('Invalid URI scheme. Scheme must be one of'\n                + ' http, https, or rtmp');\n    }\n};\n\nvar handleError = function (err, callback) {\n    if (!callback || typeof callback !== 'function') {\n        throw err;\n    }\n\n    callback(err);\n};\n\nvar handleSuccess = function (result, callback) {\n    if (!callback || typeof callback !== 'function') {\n        return result;\n    }\n\n    callback(null, result);\n};\n\nAWS.CloudFront.Signer = inherit({\n    /**\n     * A signer object can be used to generate signed URLs and cookies for granting\n     * access to content on restricted CloudFront distributions.\n     *\n     * @see http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html\n     *\n     * @param keyPairId [String]    (Required) The ID of the CloudFront key pair\n     *                              being used.\n     * @param privateKey [String]   (Required) A private key in RSA format.\n     */\n    constructor: function Signer(keyPairId, privateKey) {\n        if (keyPairId === void 0 || privateKey === void 0) {\n            throw new Error('A key pair ID and private key are required');\n        }\n\n        this.keyPairId = keyPairId;\n        this.privateKey = privateKey;\n    },\n\n    /**\n     * Create a signed Amazon CloudFront Cookie.\n     *\n     * @param options [Object]            The options to create a signed cookie.\n     * @option options url [String]     The URL to which the signature will grant\n     *                                  access. Required unless you pass in a full\n     *                                  policy.\n     * @option options expires [Number] A Unix UTC timestamp indicating when the\n     *                                  signature should expire. Required unless you\n     *                                  pass in a full policy.\n     * @option options policy [String]  A CloudFront JSON policy. Required unless\n     *                                  you pass in a url and an expiry time.\n     *\n     * @param cb [Function] if a callback is provided, this function will\n     *   pass the hash as the second parameter (after the error parameter) to\n     *   the callback function.\n     *\n     * @return [Object] if called synchronously (with no callback), returns the\n     *   signed cookie parameters.\n     * @return [null] nothing is returned if a callback is provided.\n     */\n    getSignedCookie: function (options, cb) {\n        var signatureHash = 'policy' in options\n            ? signWithCustomPolicy(options.policy, this.keyPairId, this.privateKey)\n            : signWithCannedPolicy(options.url, options.expires, this.keyPairId, this.privateKey);\n\n        var cookieHash = {};\n        for (var key in signatureHash) {\n            if (Object.prototype.hasOwnProperty.call(signatureHash, key)) {\n                cookieHash['CloudFront-' + key] = signatureHash[key];\n            }\n        }\n\n        return handleSuccess(cookieHash, cb);\n    },\n\n    /**\n     * Create a signed Amazon CloudFront URL.\n     *\n     * Keep in mind that URLs meant for use in media/flash players may have\n     * different requirements for URL formats (e.g. some require that the\n     * extension be removed, some require the file name to be prefixed\n     * - mp4:<path>, some require you to add \"/cfx/st\" into your URL).\n     *\n     * @param options [Object]          The options to create a signed URL.\n     * @option options url [String]     The URL to which the signature will grant\n     *                                  access. Any query params included with\n     *                                  the URL should be encoded. Required.\n     * @option options expires [Number] A Unix UTC timestamp indicating when the\n     *                                  signature should expire. Required unless you\n     *                                  pass in a full policy.\n     * @option options policy [String]  A CloudFront JSON policy. Required unless\n     *                                  you pass in a url and an expiry time.\n     *\n     * @param cb [Function] if a callback is provided, this function will\n     *   pass the URL as the second parameter (after the error parameter) to\n     *   the callback function.\n     *\n     * @return [String] if called synchronously (with no callback), returns the\n     *   signed URL.\n     * @return [null] nothing is returned if a callback is provided.\n     */\n    getSignedUrl: function (options, cb) {\n        try {\n            var resource = getResource(options.url);\n        } catch (err) {\n            return handleError(err, cb);\n        }\n\n        var parsedUrl = url.parse(options.url, true),\n            signatureHash = Object.prototype.hasOwnProperty.call(options, 'policy')\n                ? signWithCustomPolicy(options.policy, this.keyPairId, this.privateKey)\n                : signWithCannedPolicy(resource, options.expires, this.keyPairId, this.privateKey);\n\n        parsedUrl.search = null;\n        for (var key in signatureHash) {\n            if (Object.prototype.hasOwnProperty.call(signatureHash, key)) {\n                parsedUrl.query[key] = signatureHash[key];\n            }\n        }\n\n        try {\n            var signedUrl = determineScheme(options.url) === 'rtmp'\n                    ? getRtmpUrl(url.format(parsedUrl))\n                    : url.format(parsedUrl);\n        } catch (err) {\n            return handleError(err, cb);\n        }\n\n        return handleSuccess(signedUrl, cb);\n    }\n});\n\n/**\n * @api private\n */\nmodule.exports = AWS.CloudFront.Signer;\n"],"mappings":"AAAA,IAAIA,GAAG,GAAGC,OAAO,CAAC,SAAS,CAAC;EACxBC,GAAG,GAAGF,GAAG,CAACG,IAAI,CAACD,GAAG;EAClBE,MAAM,GAAGJ,GAAG,CAACG,IAAI,CAACC,MAAM,CAACC,GAAG;EAC5BC,YAAY,GAAGN,GAAG,CAACG,IAAI,CAACI,MAAM,CAACC,MAAM;EACrCC,OAAO,GAAGT,GAAG,CAACG,IAAI,CAACM,OAAO;AAE9B,IAAIC,WAAW,GAAG,SAAAA,CAAUC,MAAM,EAAE;EAChC,IAAIC,YAAY,GAAG;IACf,GAAG,EAAE,GAAG;IACR,GAAG,EAAE,GAAG;IACR,GAAG,EAAE;EACT,CAAC;EACD,OAAOD,MAAM,CAACE,OAAO,CAAC,UAAU,EAAE,UAAUC,KAAK,EAAE;IAC/C,OAAOF,YAAY,CAACE,KAAK,CAAC;EAC9B,CAAC,CAAC;AACN,CAAC;AAED,IAAIC,UAAU,GAAG,SAAAA,CAAUC,MAAM,EAAEC,UAAU,EAAE;EAC3C,IAAIC,IAAI,GAAGd,MAAM,CAACe,UAAU,CAAC,UAAU,CAAC;EACxCD,IAAI,CAACE,KAAK,CAACJ,MAAM,CAAC;EAClB,OAAON,WAAW,CAACQ,IAAI,CAACA,IAAI,CAACD,UAAU,EAAE,QAAQ,CAAC,CAAC;AACvD,CAAC;AAED,IAAII,oBAAoB,GAAG,SAAAA,CAAUnB,GAAG,EAAEoB,OAAO,EAAEC,SAAS,EAAEN,UAAU,EAAE;EACtE,IAAID,MAAM,GAAGQ,IAAI,CAACC,SAAS,CAAC;IACxBC,SAAS,EAAE,CACP;MACIC,QAAQ,EAAEzB,GAAG;MACb0B,SAAS,EAAE;QAAEC,YAAY,EAAE;UAAE,eAAe,EAAEP;QAAQ;MAAE;IAC5D,CAAC;EAET,CAAC,CAAC;EAEF,OAAO;IACHQ,OAAO,EAAER,OAAO;IAChB,aAAa,EAAEC,SAAS;IACxBQ,SAAS,EAAEhB,UAAU,CAACC,MAAM,CAACgB,QAAQ,CAAC,CAAC,EAAEf,UAAU;EACvD,CAAC;AACL,CAAC;AAED,IAAIgB,oBAAoB,GAAG,SAAAA,CAAUjB,MAAM,EAAEO,SAAS,EAAEN,UAAU,EAAE;EAChED,MAAM,GAAGA,MAAM,CAACH,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC;EAEnC,OAAO;IACHqB,MAAM,EAAExB,WAAW,CAACJ,YAAY,CAACU,MAAM,CAAC,CAAC;IACzC,aAAa,EAAEO,SAAS;IACxBQ,SAAS,EAAEhB,UAAU,CAACC,MAAM,EAAEC,UAAU;EAC5C,CAAC;AACL,CAAC;AAED,IAAIkB,eAAe,GAAG,SAAAA,CAAUjC,GAAG,EAAE;EACjC,IAAIkC,KAAK,GAAGlC,GAAG,CAACmC,KAAK,CAAC,KAAK,CAAC;EAC5B,IAAID,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE;IAClB,MAAM,IAAIC,KAAK,CAAC,cAAc,CAAC;EACnC;EAEA,OAAOH,KAAK,CAAC,CAAC,CAAC,CAACvB,OAAO,CAAC,GAAG,EAAE,EAAE,CAAC;AACpC,CAAC;AAED,IAAI2B,UAAU,GAAG,SAAAA,CAAUC,OAAO,EAAE;EAChC,IAAIC,MAAM,GAAGxC,GAAG,CAACyC,KAAK,CAACF,OAAO,CAAC;EAC/B,OAAOC,MAAM,CAACE,IAAI,CAAC/B,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,IAAI6B,MAAM,CAACG,IAAI,IAAI,EAAE,CAAC;AAC/D,CAAC;AAED,IAAIC,WAAW,GAAG,SAAAA,CAAU5C,GAAG,EAAE;EAC7B,QAAQiC,eAAe,CAACjC,GAAG,CAAC;IACxB,KAAK,MAAM;IACX,KAAK,OAAO;MACR,OAAOA,GAAG;IACd,KAAK,MAAM;MACP,OAAOsC,UAAU,CAACtC,GAAG,CAAC;IAC1B;MACI,MAAM,IAAIqC,KAAK,CAAC,2CAA2C,GACrD,uBAAuB,CAAC;EACtC;AACJ,CAAC;AAED,IAAIQ,WAAW,GAAG,SAAAA,CAAUC,GAAG,EAAEC,QAAQ,EAAE;EACvC,IAAI,CAACA,QAAQ,IAAI,OAAOA,QAAQ,KAAK,UAAU,EAAE;IAC7C,MAAMD,GAAG;EACb;EAEAC,QAAQ,CAACD,GAAG,CAAC;AACjB,CAAC;AAED,IAAIE,aAAa,GAAG,SAAAA,CAAUC,MAAM,EAAEF,QAAQ,EAAE;EAC5C,IAAI,CAACA,QAAQ,IAAI,OAAOA,QAAQ,KAAK,UAAU,EAAE;IAC7C,OAAOE,MAAM;EACjB;EAEAF,QAAQ,CAAC,IAAI,EAAEE,MAAM,CAAC;AAC1B,CAAC;AAEDnD,GAAG,CAACoD,UAAU,CAACC,MAAM,GAAG5C,OAAO,CAAC;EAC5B;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI6C,WAAW,EAAE,SAASD,MAAMA,CAAC9B,SAAS,EAAEN,UAAU,EAAE;IAChD,IAAIM,SAAS,KAAK,KAAK,CAAC,IAAIN,UAAU,KAAK,KAAK,CAAC,EAAE;MAC/C,MAAM,IAAIsB,KAAK,CAAC,4CAA4C,CAAC;IACjE;IAEA,IAAI,CAAChB,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACN,UAAU,GAAGA,UAAU;EAChC,CAAC;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIsC,eAAe,EAAE,SAAAA,CAAUC,OAAO,EAAEC,EAAE,EAAE;IACpC,IAAIC,aAAa,GAAG,QAAQ,IAAIF,OAAO,GACjCvB,oBAAoB,CAACuB,OAAO,CAACxC,MAAM,EAAE,IAAI,CAACO,SAAS,EAAE,IAAI,CAACN,UAAU,CAAC,GACrEI,oBAAoB,CAACmC,OAAO,CAACtD,GAAG,EAAEsD,OAAO,CAAClC,OAAO,EAAE,IAAI,CAACC,SAAS,EAAE,IAAI,CAACN,UAAU,CAAC;IAEzF,IAAI0C,UAAU,GAAG,CAAC,CAAC;IACnB,KAAK,IAAIC,GAAG,IAAIF,aAAa,EAAE;MAC3B,IAAIG,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACN,aAAa,EAAEE,GAAG,CAAC,EAAE;QAC1DD,UAAU,CAAC,aAAa,GAAGC,GAAG,CAAC,GAAGF,aAAa,CAACE,GAAG,CAAC;MACxD;IACJ;IAEA,OAAOV,aAAa,CAACS,UAAU,EAAEF,EAAE,CAAC;EACxC,CAAC;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIQ,YAAY,EAAE,SAAAA,CAAUT,OAAO,EAAEC,EAAE,EAAE;IACjC,IAAI;MACA,IAAIS,QAAQ,GAAGpB,WAAW,CAACU,OAAO,CAACtD,GAAG,CAAC;IAC3C,CAAC,CAAC,OAAO8C,GAAG,EAAE;MACV,OAAOD,WAAW,CAACC,GAAG,EAAES,EAAE,CAAC;IAC/B;IAEA,IAAIU,SAAS,GAAGjE,GAAG,CAACyC,KAAK,CAACa,OAAO,CAACtD,GAAG,EAAE,IAAI,CAAC;MACxCwD,aAAa,GAAGG,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACR,OAAO,EAAE,QAAQ,CAAC,GACjEvB,oBAAoB,CAACuB,OAAO,CAACxC,MAAM,EAAE,IAAI,CAACO,SAAS,EAAE,IAAI,CAACN,UAAU,CAAC,GACrEI,oBAAoB,CAAC6C,QAAQ,EAAEV,OAAO,CAAClC,OAAO,EAAE,IAAI,CAACC,SAAS,EAAE,IAAI,CAACN,UAAU,CAAC;IAE1FkD,SAAS,CAACC,MAAM,GAAG,IAAI;IACvB,KAAK,IAAIR,GAAG,IAAIF,aAAa,EAAE;MAC3B,IAAIG,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACN,aAAa,EAAEE,GAAG,CAAC,EAAE;QAC1DO,SAAS,CAACE,KAAK,CAACT,GAAG,CAAC,GAAGF,aAAa,CAACE,GAAG,CAAC;MAC7C;IACJ;IAEA,IAAI;MACA,IAAIU,SAAS,GAAGnC,eAAe,CAACqB,OAAO,CAACtD,GAAG,CAAC,KAAK,MAAM,GAC7CsC,UAAU,CAACtC,GAAG,CAACqE,MAAM,CAACJ,SAAS,CAAC,CAAC,GACjCjE,GAAG,CAACqE,MAAM,CAACJ,SAAS,CAAC;IACnC,CAAC,CAAC,OAAOnB,GAAG,EAAE;MACV,OAAOD,WAAW,CAACC,GAAG,EAAES,EAAE,CAAC;IAC/B;IAEA,OAAOP,aAAa,CAACoB,SAAS,EAAEb,EAAE,CAAC;EACvC;AACJ,CAAC,CAAC;;AAEF;AACA;AACA;AACAe,MAAM,CAACC,OAAO,GAAGzE,GAAG,CAACoD,UAAU,CAACC,MAAM"},"metadata":{},"sourceType":"script","externalDependencies":[]}