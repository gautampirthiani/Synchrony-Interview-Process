{"ast":null,"code":"var AWS = require('../core');\nvar byteLength = AWS.util.string.byteLength;\nvar Buffer = AWS.util.Buffer;\n\n/**\n * The managed uploader allows for easy and efficient uploading of buffers,\n * blobs, or streams, using a configurable amount of concurrency to perform\n * multipart uploads where possible. This abstraction also enables uploading\n * streams of unknown size due to the use of multipart uploads.\n *\n * To construct a managed upload object, see the {constructor} function.\n *\n * ## Tracking upload progress\n *\n * The managed upload object can also track progress by attaching an\n * 'httpUploadProgress' listener to the upload manager. This event is similar\n * to {AWS.Request~httpUploadProgress} but groups all concurrent upload progress\n * into a single event. See {AWS.S3.ManagedUpload~httpUploadProgress} for more\n * information.\n *\n * ## Handling Multipart Cleanup\n *\n * By default, this class will automatically clean up any multipart uploads\n * when an individual part upload fails. This behavior can be disabled in order\n * to manually handle failures by setting the `leavePartsOnError` configuration\n * option to `true` when initializing the upload object.\n *\n * @!event httpUploadProgress(progress)\n *   Triggered when the uploader has uploaded more data.\n *   @note The `total` property may not be set if the stream being uploaded has\n *     not yet finished chunking. In this case the `total` will be undefined\n *     until the total stream size is known.\n *   @note This event will not be emitted in Node.js 0.8.x.\n *   @param progress [map] An object containing the `loaded` and `total` bytes\n *     of the request and the `key` of the S3 object. Note that `total` may be undefined until the payload\n *     size is known.\n *   @context (see AWS.Request~send)\n */\nAWS.S3.ManagedUpload = AWS.util.inherit({\n  /**\n   * Creates a managed upload object with a set of configuration options.\n   *\n   * @note A \"Body\" parameter is required to be set prior to calling {send}.\n   * @note In Node.js, sending \"Body\" as {https://nodejs.org/dist/latest/docs/api/stream.html#stream_object_mode object-mode stream}\n   *   may result in upload hangs. Using buffer stream is preferable.\n   * @option options params [map] a map of parameters to pass to the upload\n   *   requests. The \"Body\" parameter is required to be specified either on\n   *   the service or in the params option.\n   * @note ContentMD5 should not be provided when using the managed upload object.\n   *   Instead, setting \"computeChecksums\" to true will enable automatic ContentMD5 generation\n   *   by the managed upload object.\n   * @option options queueSize [Number] (4) the size of the concurrent queue\n   *   manager to upload parts in parallel. Set to 1 for synchronous uploading\n   *   of parts. Note that the uploader will buffer at most queueSize * partSize\n   *   bytes into memory at any given time.\n   * @option options partSize [Number] (5mb) the size in bytes for each\n   *   individual part to be uploaded. Adjust the part size to ensure the number\n   *   of parts does not exceed {maxTotalParts}. See {minPartSize} for the\n   *   minimum allowed part size.\n   * @option options leavePartsOnError [Boolean] (false) whether to abort the\n   *   multipart upload if an error occurs. Set to true if you want to handle\n   *   failures manually.\n   * @option options service [AWS.S3] an optional S3 service object to use for\n   *   requests. This object might have bound parameters used by the uploader.\n   * @option options tags [Array<map>] The tags to apply to the uploaded object.\n   *   Each tag should have a `Key` and `Value` keys.\n   * @example Creating a default uploader for a stream object\n   *   var upload = new AWS.S3.ManagedUpload({\n   *     params: {Bucket: 'bucket', Key: 'key', Body: stream}\n   *   });\n   * @example Creating an uploader with concurrency of 1 and partSize of 10mb\n   *   var upload = new AWS.S3.ManagedUpload({\n   *     partSize: 10 * 1024 * 1024, queueSize: 1,\n   *     params: {Bucket: 'bucket', Key: 'key', Body: stream}\n   *   });\n   * @example Creating an uploader with tags\n   *   var upload = new AWS.S3.ManagedUpload({\n   *     params: {Bucket: 'bucket', Key: 'key', Body: stream},\n   *     tags: [{Key: 'tag1', Value: 'value1'}, {Key: 'tag2', Value: 'value2'}]\n   *   });\n   * @see send\n   */\n  constructor: function ManagedUpload(options) {\n    var self = this;\n    AWS.SequentialExecutor.call(self);\n    self.body = null;\n    self.sliceFn = null;\n    self.callback = null;\n    self.parts = {};\n    self.completeInfo = [];\n    self.fillQueue = function () {\n      self.callback(new Error('Unsupported body payload ' + typeof self.body));\n    };\n    self.configure(options);\n  },\n  /**\n   * @api private\n   */\n  configure: function configure(options) {\n    options = options || {};\n    this.partSize = this.minPartSize;\n    if (options.queueSize) this.queueSize = options.queueSize;\n    if (options.partSize) this.partSize = options.partSize;\n    if (options.leavePartsOnError) this.leavePartsOnError = true;\n    if (options.tags) {\n      if (!Array.isArray(options.tags)) {\n        throw new Error('Tags must be specified as an array; ' + typeof options.tags + ' provided.');\n      }\n      this.tags = options.tags;\n    }\n    if (this.partSize < this.minPartSize) {\n      throw new Error('partSize must be greater than ' + this.minPartSize);\n    }\n    this.service = options.service;\n    this.bindServiceObject(options.params);\n    this.validateBody();\n    this.adjustTotalBytes();\n  },\n  /**\n   * @api private\n   */\n  leavePartsOnError: false,\n  /**\n   * @api private\n   */\n  queueSize: 4,\n  /**\n   * @api private\n   */\n  partSize: null,\n  /**\n   * @readonly\n   * @return [Number] the minimum number of bytes for an individual part\n   *   upload.\n   */\n  minPartSize: 1024 * 1024 * 5,\n  /**\n   * @readonly\n   * @return [Number] the maximum allowed number of parts in a multipart upload.\n   */\n  maxTotalParts: 10000,\n  /**\n   * Initiates the managed upload for the payload.\n   *\n   * @callback callback function(err, data)\n   *   @param err [Error] an error or null if no error occurred.\n   *   @param data [map] The response data from the successful upload:\n   *     * `Location` (String) the URL of the uploaded object\n   *     * `ETag` (String) the ETag of the uploaded object\n   *     * `Bucket` (String) the bucket to which the object was uploaded\n   *     * `Key` (String) the key to which the object was uploaded\n   * @example Sending a managed upload object\n   *   var params = {Bucket: 'bucket', Key: 'key', Body: stream};\n   *   var upload = new AWS.S3.ManagedUpload({params: params});\n   *   upload.send(function(err, data) {\n   *     console.log(err, data);\n   *   });\n   */\n  send: function (callback) {\n    var self = this;\n    self.failed = false;\n    self.callback = callback || function (err) {\n      if (err) throw err;\n    };\n    var runFill = true;\n    if (self.sliceFn) {\n      self.fillQueue = self.fillBuffer;\n    } else if (AWS.util.isNode()) {\n      var Stream = AWS.util.stream.Stream;\n      if (self.body instanceof Stream) {\n        runFill = false;\n        self.fillQueue = self.fillStream;\n        self.partBuffers = [];\n        self.body.on('error', function (err) {\n          self.cleanup(err);\n        }).on('readable', function () {\n          self.fillQueue();\n        }).on('end', function () {\n          self.isDoneChunking = true;\n          self.numParts = self.totalPartNumbers;\n          self.fillQueue.call(self);\n          if (self.isDoneChunking && self.totalPartNumbers >= 1 && self.doneParts === self.numParts) {\n            self.finishMultiPart();\n          }\n        });\n      }\n    }\n    if (runFill) self.fillQueue.call(self);\n  },\n  /**\n   * @!method  promise()\n   *   Returns a 'thenable' promise.\n   *\n   *   Two callbacks can be provided to the `then` method on the returned promise.\n   *   The first callback will be called if the promise is fulfilled, and the second\n   *   callback will be called if the promise is rejected.\n   *   @callback fulfilledCallback function(data)\n   *     Called if the promise is fulfilled.\n   *     @param data [map] The response data from the successful upload:\n   *       `Location` (String) the URL of the uploaded object\n   *       `ETag` (String) the ETag of the uploaded object\n   *       `Bucket` (String) the bucket to which the object was uploaded\n   *       `Key` (String) the key to which the object was uploaded\n   *   @callback rejectedCallback function(err)\n   *     Called if the promise is rejected.\n   *     @param err [Error] an error or null if no error occurred.\n   *   @return [Promise] A promise that represents the state of the upload request.\n   *   @example Sending an upload request using promises.\n   *     var upload = s3.upload({Bucket: 'bucket', Key: 'key', Body: stream});\n   *     var promise = upload.promise();\n   *     promise.then(function(data) { ... }, function(err) { ... });\n   */\n\n  /**\n   * Aborts a managed upload, including all concurrent upload requests.\n   * @note By default, calling this function will cleanup a multipart upload\n   *   if one was created. To leave the multipart upload around after aborting\n   *   a request, configure `leavePartsOnError` to `true` in the {constructor}.\n   * @note Calling {abort} in the browser environment will not abort any requests\n   *   that are already in flight. If a multipart upload was created, any parts\n   *   not yet uploaded will not be sent, and the multipart upload will be cleaned up.\n   * @example Aborting an upload\n   *   var params = {\n   *     Bucket: 'bucket', Key: 'key',\n   *     Body: Buffer.alloc(1024 * 1024 * 25) // 25MB payload\n   *   };\n   *   var upload = s3.upload(params);\n   *   upload.send(function (err, data) {\n   *     if (err) console.log(\"Error:\", err.code, err.message);\n   *     else console.log(data);\n   *   });\n   *\n   *   // abort request in 1 second\n   *   setTimeout(upload.abort.bind(upload), 1000);\n   */\n  abort: function () {\n    var self = this;\n    //abort putObject request\n    if (self.isDoneChunking === true && self.totalPartNumbers === 1 && self.singlePart) {\n      self.singlePart.abort();\n    } else {\n      self.cleanup(AWS.util.error(new Error('Request aborted by user'), {\n        code: 'RequestAbortedError',\n        retryable: false\n      }));\n    }\n  },\n  /**\n   * @api private\n   */\n  validateBody: function validateBody() {\n    var self = this;\n    self.body = self.service.config.params.Body;\n    if (typeof self.body === 'string') {\n      self.body = AWS.util.buffer.toBuffer(self.body);\n    } else if (!self.body) {\n      throw new Error('params.Body is required');\n    }\n    self.sliceFn = AWS.util.arraySliceFn(self.body);\n  },\n  /**\n   * @api private\n   */\n  bindServiceObject: function bindServiceObject(params) {\n    params = params || {};\n    var self = this;\n    // bind parameters to new service object\n    if (!self.service) {\n      self.service = new AWS.S3({\n        params: params\n      });\n    } else {\n      // Create a new S3 client from the supplied client's constructor.\n      var service = self.service;\n      var config = AWS.util.copy(service.config);\n      config.signatureVersion = service.getSignatureVersion();\n      self.service = new service.constructor.__super__(config);\n      self.service.config.params = AWS.util.merge(self.service.config.params || {}, params);\n      Object.defineProperty(self.service, '_originalConfig', {\n        get: function () {\n          return service._originalConfig;\n        },\n        enumerable: false,\n        configurable: true\n      });\n    }\n  },\n  /**\n   * @api private\n   */\n  adjustTotalBytes: function adjustTotalBytes() {\n    var self = this;\n    try {\n      // try to get totalBytes\n      self.totalBytes = byteLength(self.body);\n    } catch (e) {}\n\n    // try to adjust partSize if we know payload length\n    if (self.totalBytes) {\n      var newPartSize = Math.ceil(self.totalBytes / self.maxTotalParts);\n      if (newPartSize > self.partSize) self.partSize = newPartSize;\n    } else {\n      self.totalBytes = undefined;\n    }\n  },\n  /**\n   * @api private\n   */\n  isDoneChunking: false,\n  /**\n   * @api private\n   */\n  partPos: 0,\n  /**\n   * @api private\n   */\n  totalChunkedBytes: 0,\n  /**\n   * @api private\n   */\n  totalUploadedBytes: 0,\n  /**\n   * @api private\n   */\n  totalBytes: undefined,\n  /**\n   * @api private\n   */\n  numParts: 0,\n  /**\n   * @api private\n   */\n  totalPartNumbers: 0,\n  /**\n   * @api private\n   */\n  activeParts: 0,\n  /**\n   * @api private\n   */\n  doneParts: 0,\n  /**\n   * @api private\n   */\n  parts: null,\n  /**\n   * @api private\n   */\n  completeInfo: null,\n  /**\n   * @api private\n   */\n  failed: false,\n  /**\n   * @api private\n   */\n  multipartReq: null,\n  /**\n   * @api private\n   */\n  partBuffers: null,\n  /**\n   * @api private\n   */\n  partBufferLength: 0,\n  /**\n   * @api private\n   */\n  fillBuffer: function fillBuffer() {\n    var self = this;\n    var bodyLen = byteLength(self.body);\n    if (bodyLen === 0) {\n      self.isDoneChunking = true;\n      self.numParts = 1;\n      self.nextChunk(self.body);\n      return;\n    }\n    while (self.activeParts < self.queueSize && self.partPos < bodyLen) {\n      var endPos = Math.min(self.partPos + self.partSize, bodyLen);\n      var buf = self.sliceFn.call(self.body, self.partPos, endPos);\n      self.partPos += self.partSize;\n      if (byteLength(buf) < self.partSize || self.partPos === bodyLen) {\n        self.isDoneChunking = true;\n        self.numParts = self.totalPartNumbers + 1;\n      }\n      self.nextChunk(buf);\n    }\n  },\n  /**\n   * @api private\n   */\n  fillStream: function fillStream() {\n    var self = this;\n    if (self.activeParts >= self.queueSize) return;\n    var buf = self.body.read(self.partSize - self.partBufferLength) || self.body.read();\n    if (buf) {\n      self.partBuffers.push(buf);\n      self.partBufferLength += buf.length;\n      self.totalChunkedBytes += buf.length;\n    }\n    if (self.partBufferLength >= self.partSize) {\n      // if we have single buffer we avoid copyfull concat\n      var pbuf = self.partBuffers.length === 1 ? self.partBuffers[0] : Buffer.concat(self.partBuffers);\n      self.partBuffers = [];\n      self.partBufferLength = 0;\n\n      // if we have more than partSize, push the rest back on the queue\n      if (pbuf.length > self.partSize) {\n        var rest = pbuf.slice(self.partSize);\n        self.partBuffers.push(rest);\n        self.partBufferLength += rest.length;\n        pbuf = pbuf.slice(0, self.partSize);\n      }\n      self.nextChunk(pbuf);\n    }\n    if (self.isDoneChunking && !self.isDoneSending) {\n      // if we have single buffer we avoid copyfull concat\n      pbuf = self.partBuffers.length === 1 ? self.partBuffers[0] : Buffer.concat(self.partBuffers);\n      self.partBuffers = [];\n      self.partBufferLength = 0;\n      self.totalBytes = self.totalChunkedBytes;\n      self.isDoneSending = true;\n      if (self.numParts === 0 || pbuf.length > 0) {\n        self.numParts++;\n        self.nextChunk(pbuf);\n      }\n    }\n    self.body.read(0);\n  },\n  /**\n   * @api private\n   */\n  nextChunk: function nextChunk(chunk) {\n    var self = this;\n    if (self.failed) return null;\n    var partNumber = ++self.totalPartNumbers;\n    if (self.isDoneChunking && partNumber === 1) {\n      var params = {\n        Body: chunk\n      };\n      if (this.tags) {\n        params.Tagging = this.getTaggingHeader();\n      }\n      var req = self.service.putObject(params);\n      req._managedUpload = self;\n      req.on('httpUploadProgress', self.progress).send(self.finishSinglePart);\n      self.singlePart = req; //save the single part request\n      return null;\n    } else if (self.service.config.params.ContentMD5) {\n      var err = AWS.util.error(new Error('The Content-MD5 you specified is invalid for multi-part uploads.'), {\n        code: 'InvalidDigest',\n        retryable: false\n      });\n      self.cleanup(err);\n      return null;\n    }\n    if (self.completeInfo[partNumber] && self.completeInfo[partNumber].ETag !== null) {\n      return null; // Already uploaded this part.\n    }\n\n    self.activeParts++;\n    if (!self.service.config.params.UploadId) {\n      if (!self.multipartReq) {\n        // create multipart\n        self.multipartReq = self.service.createMultipartUpload();\n        self.multipartReq.on('success', function (resp) {\n          self.service.config.params.UploadId = resp.data.UploadId;\n          self.multipartReq = null;\n        });\n        self.queueChunks(chunk, partNumber);\n        self.multipartReq.on('error', function (err) {\n          self.cleanup(err);\n        });\n        self.multipartReq.send();\n      } else {\n        self.queueChunks(chunk, partNumber);\n      }\n    } else {\n      // multipart is created, just send\n      self.uploadPart(chunk, partNumber);\n    }\n  },\n  /**\n   * @api private\n   */\n  getTaggingHeader: function getTaggingHeader() {\n    var kvPairStrings = [];\n    for (var i = 0; i < this.tags.length; i++) {\n      kvPairStrings.push(AWS.util.uriEscape(this.tags[i].Key) + '=' + AWS.util.uriEscape(this.tags[i].Value));\n    }\n    return kvPairStrings.join('&');\n  },\n  /**\n   * @api private\n   */\n  uploadPart: function uploadPart(chunk, partNumber) {\n    var self = this;\n    var partParams = {\n      Body: chunk,\n      ContentLength: AWS.util.string.byteLength(chunk),\n      PartNumber: partNumber\n    };\n    var partInfo = {\n      ETag: null,\n      PartNumber: partNumber\n    };\n    self.completeInfo[partNumber] = partInfo;\n    var req = self.service.uploadPart(partParams);\n    self.parts[partNumber] = req;\n    req._lastUploadedBytes = 0;\n    req._managedUpload = self;\n    req.on('httpUploadProgress', self.progress);\n    req.send(function (err, data) {\n      delete self.parts[partParams.PartNumber];\n      self.activeParts--;\n      if (!err && (!data || !data.ETag)) {\n        var message = 'No access to ETag property on response.';\n        if (AWS.util.isBrowser()) {\n          message += ' Check CORS configuration to expose ETag header.';\n        }\n        err = AWS.util.error(new Error(message), {\n          code: 'ETagMissing',\n          retryable: false\n        });\n      }\n      if (err) return self.cleanup(err);\n      //prevent sending part being returned twice (https://github.com/aws/aws-sdk-js/issues/2304)\n      if (self.completeInfo[partNumber] && self.completeInfo[partNumber].ETag !== null) return null;\n      partInfo.ETag = data.ETag;\n      self.doneParts++;\n      if (self.isDoneChunking && self.doneParts === self.totalPartNumbers) {\n        self.finishMultiPart();\n      } else {\n        self.fillQueue.call(self);\n      }\n    });\n  },\n  /**\n   * @api private\n   */\n  queueChunks: function queueChunks(chunk, partNumber) {\n    var self = this;\n    self.multipartReq.on('success', function () {\n      self.uploadPart(chunk, partNumber);\n    });\n  },\n  /**\n   * @api private\n   */\n  cleanup: function cleanup(err) {\n    var self = this;\n    if (self.failed) return;\n\n    // clean up stream\n    if (typeof self.body.removeAllListeners === 'function' && typeof self.body.resume === 'function') {\n      self.body.removeAllListeners('readable');\n      self.body.removeAllListeners('end');\n      self.body.resume();\n    }\n\n    // cleanup multipartReq listeners\n    if (self.multipartReq) {\n      self.multipartReq.removeAllListeners('success');\n      self.multipartReq.removeAllListeners('error');\n      self.multipartReq.removeAllListeners('complete');\n      delete self.multipartReq;\n    }\n    if (self.service.config.params.UploadId && !self.leavePartsOnError) {\n      self.service.abortMultipartUpload().send();\n    } else if (self.leavePartsOnError) {\n      self.isDoneChunking = false;\n    }\n    AWS.util.each(self.parts, function (partNumber, part) {\n      part.removeAllListeners('complete');\n      part.abort();\n    });\n    self.activeParts = 0;\n    self.partPos = 0;\n    self.numParts = 0;\n    self.totalPartNumbers = 0;\n    self.parts = {};\n    self.failed = true;\n    self.callback(err);\n  },\n  /**\n   * @api private\n   */\n  finishMultiPart: function finishMultiPart() {\n    var self = this;\n    var completeParams = {\n      MultipartUpload: {\n        Parts: self.completeInfo.slice(1)\n      }\n    };\n    self.service.completeMultipartUpload(completeParams, function (err, data) {\n      if (err) {\n        return self.cleanup(err);\n      }\n      if (data && typeof data.Location === 'string') {\n        data.Location = data.Location.replace(/%2F/g, '/');\n      }\n      if (Array.isArray(self.tags)) {\n        for (var i = 0; i < self.tags.length; i++) {\n          self.tags[i].Value = String(self.tags[i].Value);\n        }\n        self.service.putObjectTagging({\n          Tagging: {\n            TagSet: self.tags\n          }\n        }, function (e, d) {\n          if (e) {\n            self.callback(e);\n          } else {\n            self.callback(e, data);\n          }\n        });\n      } else {\n        self.callback(err, data);\n      }\n    });\n  },\n  /**\n   * @api private\n   */\n  finishSinglePart: function finishSinglePart(err, data) {\n    var upload = this.request._managedUpload;\n    var httpReq = this.request.httpRequest;\n    var endpoint = httpReq.endpoint;\n    if (err) return upload.callback(err);\n    data.Location = [endpoint.protocol, '//', endpoint.host, httpReq.path].join('');\n    data.key = this.request.params.Key; // will stay undocumented\n    data.Key = this.request.params.Key;\n    data.Bucket = this.request.params.Bucket;\n    upload.callback(err, data);\n  },\n  /**\n   * @api private\n   */\n  progress: function progress(info) {\n    var upload = this._managedUpload;\n    if (this.operation === 'putObject') {\n      info.part = 1;\n      info.key = this.params.Key;\n    } else {\n      upload.totalUploadedBytes += info.loaded - this._lastUploadedBytes;\n      this._lastUploadedBytes = info.loaded;\n      info = {\n        loaded: upload.totalUploadedBytes,\n        total: upload.totalBytes,\n        part: this.params.PartNumber,\n        key: this.params.Key\n      };\n    }\n    upload.emit('httpUploadProgress', [info]);\n  }\n});\nAWS.util.mixin(AWS.S3.ManagedUpload, AWS.SequentialExecutor);\n\n/**\n * @api private\n */\nAWS.S3.ManagedUpload.addPromisesToClass = function addPromisesToClass(PromiseDependency) {\n  this.prototype.promise = AWS.util.promisifyMethod('send', PromiseDependency);\n};\n\n/**\n * @api private\n */\nAWS.S3.ManagedUpload.deletePromisesFromClass = function deletePromisesFromClass() {\n  delete this.prototype.promise;\n};\nAWS.util.addPromises(AWS.S3.ManagedUpload);\n\n/**\n * @api private\n */\nmodule.exports = AWS.S3.ManagedUpload;","map":{"version":3,"names":["AWS","require","byteLength","util","string","Buffer","S3","ManagedUpload","inherit","constructor","options","self","SequentialExecutor","call","body","sliceFn","callback","parts","completeInfo","fillQueue","Error","configure","partSize","minPartSize","queueSize","leavePartsOnError","tags","Array","isArray","service","bindServiceObject","params","validateBody","adjustTotalBytes","maxTotalParts","send","failed","err","runFill","fillBuffer","isNode","Stream","stream","fillStream","partBuffers","on","cleanup","isDoneChunking","numParts","totalPartNumbers","doneParts","finishMultiPart","abort","singlePart","error","code","retryable","config","Body","buffer","toBuffer","arraySliceFn","copy","signatureVersion","getSignatureVersion","__super__","merge","Object","defineProperty","get","_originalConfig","enumerable","configurable","totalBytes","e","newPartSize","Math","ceil","undefined","partPos","totalChunkedBytes","totalUploadedBytes","activeParts","multipartReq","partBufferLength","bodyLen","nextChunk","endPos","min","buf","read","push","length","pbuf","concat","rest","slice","isDoneSending","chunk","partNumber","Tagging","getTaggingHeader","req","putObject","_managedUpload","progress","finishSinglePart","ContentMD5","ETag","UploadId","createMultipartUpload","resp","data","queueChunks","uploadPart","kvPairStrings","i","uriEscape","Key","Value","join","partParams","ContentLength","PartNumber","partInfo","_lastUploadedBytes","message","isBrowser","removeAllListeners","resume","abortMultipartUpload","each","part","completeParams","MultipartUpload","Parts","completeMultipartUpload","Location","replace","String","putObjectTagging","TagSet","d","upload","request","httpReq","httpRequest","endpoint","protocol","host","path","key","Bucket","info","operation","loaded","total","emit","mixin","addPromisesToClass","PromiseDependency","prototype","promise","promisifyMethod","deletePromisesFromClass","addPromises","module","exports"],"sources":["/Users/damianmiskow/Desktop/Projects/Synchrony-Interview-Process/node_modules/aws-sdk/lib/s3/managed_upload.js"],"sourcesContent":["var AWS = require('../core');\nvar byteLength = AWS.util.string.byteLength;\nvar Buffer = AWS.util.Buffer;\n\n/**\n * The managed uploader allows for easy and efficient uploading of buffers,\n * blobs, or streams, using a configurable amount of concurrency to perform\n * multipart uploads where possible. This abstraction also enables uploading\n * streams of unknown size due to the use of multipart uploads.\n *\n * To construct a managed upload object, see the {constructor} function.\n *\n * ## Tracking upload progress\n *\n * The managed upload object can also track progress by attaching an\n * 'httpUploadProgress' listener to the upload manager. This event is similar\n * to {AWS.Request~httpUploadProgress} but groups all concurrent upload progress\n * into a single event. See {AWS.S3.ManagedUpload~httpUploadProgress} for more\n * information.\n *\n * ## Handling Multipart Cleanup\n *\n * By default, this class will automatically clean up any multipart uploads\n * when an individual part upload fails. This behavior can be disabled in order\n * to manually handle failures by setting the `leavePartsOnError` configuration\n * option to `true` when initializing the upload object.\n *\n * @!event httpUploadProgress(progress)\n *   Triggered when the uploader has uploaded more data.\n *   @note The `total` property may not be set if the stream being uploaded has\n *     not yet finished chunking. In this case the `total` will be undefined\n *     until the total stream size is known.\n *   @note This event will not be emitted in Node.js 0.8.x.\n *   @param progress [map] An object containing the `loaded` and `total` bytes\n *     of the request and the `key` of the S3 object. Note that `total` may be undefined until the payload\n *     size is known.\n *   @context (see AWS.Request~send)\n */\nAWS.S3.ManagedUpload = AWS.util.inherit({\n  /**\n   * Creates a managed upload object with a set of configuration options.\n   *\n   * @note A \"Body\" parameter is required to be set prior to calling {send}.\n   * @note In Node.js, sending \"Body\" as {https://nodejs.org/dist/latest/docs/api/stream.html#stream_object_mode object-mode stream}\n   *   may result in upload hangs. Using buffer stream is preferable.\n   * @option options params [map] a map of parameters to pass to the upload\n   *   requests. The \"Body\" parameter is required to be specified either on\n   *   the service or in the params option.\n   * @note ContentMD5 should not be provided when using the managed upload object.\n   *   Instead, setting \"computeChecksums\" to true will enable automatic ContentMD5 generation\n   *   by the managed upload object.\n   * @option options queueSize [Number] (4) the size of the concurrent queue\n   *   manager to upload parts in parallel. Set to 1 for synchronous uploading\n   *   of parts. Note that the uploader will buffer at most queueSize * partSize\n   *   bytes into memory at any given time.\n   * @option options partSize [Number] (5mb) the size in bytes for each\n   *   individual part to be uploaded. Adjust the part size to ensure the number\n   *   of parts does not exceed {maxTotalParts}. See {minPartSize} for the\n   *   minimum allowed part size.\n   * @option options leavePartsOnError [Boolean] (false) whether to abort the\n   *   multipart upload if an error occurs. Set to true if you want to handle\n   *   failures manually.\n   * @option options service [AWS.S3] an optional S3 service object to use for\n   *   requests. This object might have bound parameters used by the uploader.\n   * @option options tags [Array<map>] The tags to apply to the uploaded object.\n   *   Each tag should have a `Key` and `Value` keys.\n   * @example Creating a default uploader for a stream object\n   *   var upload = new AWS.S3.ManagedUpload({\n   *     params: {Bucket: 'bucket', Key: 'key', Body: stream}\n   *   });\n   * @example Creating an uploader with concurrency of 1 and partSize of 10mb\n   *   var upload = new AWS.S3.ManagedUpload({\n   *     partSize: 10 * 1024 * 1024, queueSize: 1,\n   *     params: {Bucket: 'bucket', Key: 'key', Body: stream}\n   *   });\n   * @example Creating an uploader with tags\n   *   var upload = new AWS.S3.ManagedUpload({\n   *     params: {Bucket: 'bucket', Key: 'key', Body: stream},\n   *     tags: [{Key: 'tag1', Value: 'value1'}, {Key: 'tag2', Value: 'value2'}]\n   *   });\n   * @see send\n   */\n  constructor: function ManagedUpload(options) {\n    var self = this;\n    AWS.SequentialExecutor.call(self);\n    self.body = null;\n    self.sliceFn = null;\n    self.callback = null;\n    self.parts = {};\n    self.completeInfo = [];\n    self.fillQueue = function() {\n      self.callback(new Error('Unsupported body payload ' + typeof self.body));\n    };\n\n    self.configure(options);\n  },\n\n  /**\n   * @api private\n   */\n  configure: function configure(options) {\n    options = options || {};\n    this.partSize = this.minPartSize;\n\n    if (options.queueSize) this.queueSize = options.queueSize;\n    if (options.partSize) this.partSize = options.partSize;\n    if (options.leavePartsOnError) this.leavePartsOnError = true;\n    if (options.tags) {\n      if (!Array.isArray(options.tags)) {\n        throw new Error('Tags must be specified as an array; ' +\n          typeof options.tags + ' provided.');\n      }\n      this.tags = options.tags;\n    }\n\n    if (this.partSize < this.minPartSize) {\n      throw new Error('partSize must be greater than ' +\n                      this.minPartSize);\n    }\n\n    this.service = options.service;\n    this.bindServiceObject(options.params);\n    this.validateBody();\n    this.adjustTotalBytes();\n  },\n\n  /**\n   * @api private\n   */\n  leavePartsOnError: false,\n\n  /**\n   * @api private\n   */\n  queueSize: 4,\n\n  /**\n   * @api private\n   */\n  partSize: null,\n\n  /**\n   * @readonly\n   * @return [Number] the minimum number of bytes for an individual part\n   *   upload.\n   */\n  minPartSize: 1024 * 1024 * 5,\n\n  /**\n   * @readonly\n   * @return [Number] the maximum allowed number of parts in a multipart upload.\n   */\n  maxTotalParts: 10000,\n\n  /**\n   * Initiates the managed upload for the payload.\n   *\n   * @callback callback function(err, data)\n   *   @param err [Error] an error or null if no error occurred.\n   *   @param data [map] The response data from the successful upload:\n   *     * `Location` (String) the URL of the uploaded object\n   *     * `ETag` (String) the ETag of the uploaded object\n   *     * `Bucket` (String) the bucket to which the object was uploaded\n   *     * `Key` (String) the key to which the object was uploaded\n   * @example Sending a managed upload object\n   *   var params = {Bucket: 'bucket', Key: 'key', Body: stream};\n   *   var upload = new AWS.S3.ManagedUpload({params: params});\n   *   upload.send(function(err, data) {\n   *     console.log(err, data);\n   *   });\n   */\n  send: function(callback) {\n    var self = this;\n    self.failed = false;\n    self.callback = callback || function(err) { if (err) throw err; };\n\n    var runFill = true;\n    if (self.sliceFn) {\n      self.fillQueue = self.fillBuffer;\n    } else if (AWS.util.isNode()) {\n      var Stream = AWS.util.stream.Stream;\n      if (self.body instanceof Stream) {\n        runFill = false;\n        self.fillQueue = self.fillStream;\n        self.partBuffers = [];\n        self.body.\n          on('error', function(err) { self.cleanup(err); }).\n          on('readable', function() { self.fillQueue(); }).\n          on('end', function() {\n            self.isDoneChunking = true;\n            self.numParts = self.totalPartNumbers;\n            self.fillQueue.call(self);\n\n            if (self.isDoneChunking && self.totalPartNumbers >= 1 && self.doneParts === self.numParts) {\n              self.finishMultiPart();\n            }\n          });\n      }\n    }\n\n    if (runFill) self.fillQueue.call(self);\n  },\n\n  /**\n   * @!method  promise()\n   *   Returns a 'thenable' promise.\n   *\n   *   Two callbacks can be provided to the `then` method on the returned promise.\n   *   The first callback will be called if the promise is fulfilled, and the second\n   *   callback will be called if the promise is rejected.\n   *   @callback fulfilledCallback function(data)\n   *     Called if the promise is fulfilled.\n   *     @param data [map] The response data from the successful upload:\n   *       `Location` (String) the URL of the uploaded object\n   *       `ETag` (String) the ETag of the uploaded object\n   *       `Bucket` (String) the bucket to which the object was uploaded\n   *       `Key` (String) the key to which the object was uploaded\n   *   @callback rejectedCallback function(err)\n   *     Called if the promise is rejected.\n   *     @param err [Error] an error or null if no error occurred.\n   *   @return [Promise] A promise that represents the state of the upload request.\n   *   @example Sending an upload request using promises.\n   *     var upload = s3.upload({Bucket: 'bucket', Key: 'key', Body: stream});\n   *     var promise = upload.promise();\n   *     promise.then(function(data) { ... }, function(err) { ... });\n   */\n\n  /**\n   * Aborts a managed upload, including all concurrent upload requests.\n   * @note By default, calling this function will cleanup a multipart upload\n   *   if one was created. To leave the multipart upload around after aborting\n   *   a request, configure `leavePartsOnError` to `true` in the {constructor}.\n   * @note Calling {abort} in the browser environment will not abort any requests\n   *   that are already in flight. If a multipart upload was created, any parts\n   *   not yet uploaded will not be sent, and the multipart upload will be cleaned up.\n   * @example Aborting an upload\n   *   var params = {\n   *     Bucket: 'bucket', Key: 'key',\n   *     Body: Buffer.alloc(1024 * 1024 * 25) // 25MB payload\n   *   };\n   *   var upload = s3.upload(params);\n   *   upload.send(function (err, data) {\n   *     if (err) console.log(\"Error:\", err.code, err.message);\n   *     else console.log(data);\n   *   });\n   *\n   *   // abort request in 1 second\n   *   setTimeout(upload.abort.bind(upload), 1000);\n   */\n  abort: function() {\n    var self = this;\n    //abort putObject request\n    if (self.isDoneChunking === true && self.totalPartNumbers === 1 && self.singlePart) {\n      self.singlePart.abort();\n    } else {\n      self.cleanup(AWS.util.error(new Error('Request aborted by user'), {\n        code: 'RequestAbortedError', retryable: false\n      }));\n    }\n  },\n\n  /**\n   * @api private\n   */\n  validateBody: function validateBody() {\n    var self = this;\n    self.body = self.service.config.params.Body;\n    if (typeof self.body === 'string') {\n      self.body = AWS.util.buffer.toBuffer(self.body);\n    } else if (!self.body) {\n      throw new Error('params.Body is required');\n    }\n    self.sliceFn = AWS.util.arraySliceFn(self.body);\n  },\n\n  /**\n   * @api private\n   */\n  bindServiceObject: function bindServiceObject(params) {\n    params = params || {};\n    var self = this;\n    // bind parameters to new service object\n    if (!self.service) {\n      self.service = new AWS.S3({params: params});\n    } else {\n      // Create a new S3 client from the supplied client's constructor.\n      var service = self.service;\n      var config = AWS.util.copy(service.config);\n      config.signatureVersion = service.getSignatureVersion();\n      self.service = new service.constructor.__super__(config);\n      self.service.config.params =\n        AWS.util.merge(self.service.config.params || {}, params);\n      Object.defineProperty(self.service, '_originalConfig', {\n        get: function() { return service._originalConfig; },\n        enumerable: false,\n        configurable: true\n      });\n    }\n  },\n\n  /**\n   * @api private\n   */\n  adjustTotalBytes: function adjustTotalBytes() {\n    var self = this;\n    try { // try to get totalBytes\n      self.totalBytes = byteLength(self.body);\n    } catch (e) { }\n\n    // try to adjust partSize if we know payload length\n    if (self.totalBytes) {\n      var newPartSize = Math.ceil(self.totalBytes / self.maxTotalParts);\n      if (newPartSize > self.partSize) self.partSize = newPartSize;\n    } else {\n      self.totalBytes = undefined;\n    }\n  },\n\n  /**\n   * @api private\n   */\n  isDoneChunking: false,\n\n  /**\n   * @api private\n   */\n  partPos: 0,\n\n  /**\n   * @api private\n   */\n  totalChunkedBytes: 0,\n\n  /**\n   * @api private\n   */\n  totalUploadedBytes: 0,\n\n  /**\n   * @api private\n   */\n  totalBytes: undefined,\n\n  /**\n   * @api private\n   */\n  numParts: 0,\n\n  /**\n   * @api private\n   */\n  totalPartNumbers: 0,\n\n  /**\n   * @api private\n   */\n  activeParts: 0,\n\n  /**\n   * @api private\n   */\n  doneParts: 0,\n\n  /**\n   * @api private\n   */\n  parts: null,\n\n  /**\n   * @api private\n   */\n  completeInfo: null,\n\n  /**\n   * @api private\n   */\n  failed: false,\n\n  /**\n   * @api private\n   */\n  multipartReq: null,\n\n  /**\n   * @api private\n   */\n  partBuffers: null,\n\n  /**\n   * @api private\n   */\n  partBufferLength: 0,\n\n  /**\n   * @api private\n   */\n  fillBuffer: function fillBuffer() {\n    var self = this;\n    var bodyLen = byteLength(self.body);\n\n    if (bodyLen === 0) {\n      self.isDoneChunking = true;\n      self.numParts = 1;\n      self.nextChunk(self.body);\n      return;\n    }\n\n    while (self.activeParts < self.queueSize && self.partPos < bodyLen) {\n      var endPos = Math.min(self.partPos + self.partSize, bodyLen);\n      var buf = self.sliceFn.call(self.body, self.partPos, endPos);\n      self.partPos += self.partSize;\n\n      if (byteLength(buf) < self.partSize || self.partPos === bodyLen) {\n        self.isDoneChunking = true;\n        self.numParts = self.totalPartNumbers + 1;\n      }\n      self.nextChunk(buf);\n    }\n  },\n\n  /**\n   * @api private\n   */\n  fillStream: function fillStream() {\n    var self = this;\n    if (self.activeParts >= self.queueSize) return;\n\n    var buf = self.body.read(self.partSize - self.partBufferLength) ||\n              self.body.read();\n    if (buf) {\n      self.partBuffers.push(buf);\n      self.partBufferLength += buf.length;\n      self.totalChunkedBytes += buf.length;\n    }\n\n    if (self.partBufferLength >= self.partSize) {\n      // if we have single buffer we avoid copyfull concat\n      var pbuf = self.partBuffers.length === 1 ?\n        self.partBuffers[0] : Buffer.concat(self.partBuffers);\n      self.partBuffers = [];\n      self.partBufferLength = 0;\n\n      // if we have more than partSize, push the rest back on the queue\n      if (pbuf.length > self.partSize) {\n        var rest = pbuf.slice(self.partSize);\n        self.partBuffers.push(rest);\n        self.partBufferLength += rest.length;\n        pbuf = pbuf.slice(0, self.partSize);\n      }\n\n      self.nextChunk(pbuf);\n    }\n\n    if (self.isDoneChunking && !self.isDoneSending) {\n      // if we have single buffer we avoid copyfull concat\n      pbuf = self.partBuffers.length === 1 ?\n          self.partBuffers[0] : Buffer.concat(self.partBuffers);\n      self.partBuffers = [];\n      self.partBufferLength = 0;\n      self.totalBytes = self.totalChunkedBytes;\n      self.isDoneSending = true;\n\n      if (self.numParts === 0 || pbuf.length > 0) {\n        self.numParts++;\n        self.nextChunk(pbuf);\n      }\n    }\n\n    self.body.read(0);\n  },\n\n  /**\n   * @api private\n   */\n  nextChunk: function nextChunk(chunk) {\n    var self = this;\n    if (self.failed) return null;\n\n    var partNumber = ++self.totalPartNumbers;\n    if (self.isDoneChunking && partNumber === 1) {\n      var params = {Body: chunk};\n      if (this.tags) {\n        params.Tagging = this.getTaggingHeader();\n      }\n      var req = self.service.putObject(params);\n      req._managedUpload = self;\n      req.on('httpUploadProgress', self.progress).send(self.finishSinglePart);\n      self.singlePart = req; //save the single part request\n      return null;\n    } else if (self.service.config.params.ContentMD5) {\n      var err = AWS.util.error(new Error('The Content-MD5 you specified is invalid for multi-part uploads.'), {\n        code: 'InvalidDigest', retryable: false\n      });\n\n      self.cleanup(err);\n      return null;\n    }\n\n    if (self.completeInfo[partNumber] && self.completeInfo[partNumber].ETag !== null) {\n      return null; // Already uploaded this part.\n    }\n\n    self.activeParts++;\n    if (!self.service.config.params.UploadId) {\n\n      if (!self.multipartReq) { // create multipart\n        self.multipartReq = self.service.createMultipartUpload();\n        self.multipartReq.on('success', function(resp) {\n          self.service.config.params.UploadId = resp.data.UploadId;\n          self.multipartReq = null;\n        });\n        self.queueChunks(chunk, partNumber);\n        self.multipartReq.on('error', function(err) {\n          self.cleanup(err);\n        });\n        self.multipartReq.send();\n      } else {\n        self.queueChunks(chunk, partNumber);\n      }\n    } else { // multipart is created, just send\n      self.uploadPart(chunk, partNumber);\n    }\n  },\n\n  /**\n   * @api private\n   */\n  getTaggingHeader: function getTaggingHeader() {\n    var kvPairStrings = [];\n    for (var i = 0; i < this.tags.length; i++) {\n      kvPairStrings.push(AWS.util.uriEscape(this.tags[i].Key) + '=' +\n        AWS.util.uriEscape(this.tags[i].Value));\n    }\n\n    return kvPairStrings.join('&');\n  },\n\n  /**\n   * @api private\n   */\n  uploadPart: function uploadPart(chunk, partNumber) {\n    var self = this;\n\n    var partParams = {\n      Body: chunk,\n      ContentLength: AWS.util.string.byteLength(chunk),\n      PartNumber: partNumber\n    };\n\n    var partInfo = {ETag: null, PartNumber: partNumber};\n    self.completeInfo[partNumber] = partInfo;\n\n    var req = self.service.uploadPart(partParams);\n    self.parts[partNumber] = req;\n    req._lastUploadedBytes = 0;\n    req._managedUpload = self;\n    req.on('httpUploadProgress', self.progress);\n    req.send(function(err, data) {\n      delete self.parts[partParams.PartNumber];\n      self.activeParts--;\n\n      if (!err && (!data || !data.ETag)) {\n        var message = 'No access to ETag property on response.';\n        if (AWS.util.isBrowser()) {\n          message += ' Check CORS configuration to expose ETag header.';\n        }\n\n        err = AWS.util.error(new Error(message), {\n          code: 'ETagMissing', retryable: false\n        });\n      }\n      if (err) return self.cleanup(err);\n      //prevent sending part being returned twice (https://github.com/aws/aws-sdk-js/issues/2304)\n      if (self.completeInfo[partNumber] && self.completeInfo[partNumber].ETag !== null) return null;\n      partInfo.ETag = data.ETag;\n      self.doneParts++;\n      if (self.isDoneChunking && self.doneParts === self.totalPartNumbers) {\n        self.finishMultiPart();\n      } else {\n        self.fillQueue.call(self);\n      }\n    });\n  },\n\n  /**\n   * @api private\n   */\n  queueChunks: function queueChunks(chunk, partNumber) {\n    var self = this;\n    self.multipartReq.on('success', function() {\n      self.uploadPart(chunk, partNumber);\n    });\n  },\n\n  /**\n   * @api private\n   */\n  cleanup: function cleanup(err) {\n    var self = this;\n    if (self.failed) return;\n\n    // clean up stream\n    if (typeof self.body.removeAllListeners === 'function' &&\n        typeof self.body.resume === 'function') {\n      self.body.removeAllListeners('readable');\n      self.body.removeAllListeners('end');\n      self.body.resume();\n    }\n\n    // cleanup multipartReq listeners\n    if (self.multipartReq) {\n      self.multipartReq.removeAllListeners('success');\n      self.multipartReq.removeAllListeners('error');\n      self.multipartReq.removeAllListeners('complete');\n      delete self.multipartReq;\n    }\n\n    if (self.service.config.params.UploadId && !self.leavePartsOnError) {\n      self.service.abortMultipartUpload().send();\n    } else if (self.leavePartsOnError) {\n      self.isDoneChunking = false;\n    }\n\n    AWS.util.each(self.parts, function(partNumber, part) {\n      part.removeAllListeners('complete');\n      part.abort();\n    });\n\n    self.activeParts = 0;\n    self.partPos = 0;\n    self.numParts = 0;\n    self.totalPartNumbers = 0;\n    self.parts = {};\n    self.failed = true;\n    self.callback(err);\n  },\n\n  /**\n   * @api private\n   */\n  finishMultiPart: function finishMultiPart() {\n    var self = this;\n    var completeParams = { MultipartUpload: { Parts: self.completeInfo.slice(1) } };\n    self.service.completeMultipartUpload(completeParams, function(err, data) {\n      if (err) {\n        return self.cleanup(err);\n      }\n\n      if (data && typeof data.Location === 'string') {\n        data.Location = data.Location.replace(/%2F/g, '/');\n      }\n\n      if (Array.isArray(self.tags)) {\n        for (var i = 0; i < self.tags.length; i++) {\n          self.tags[i].Value = String(self.tags[i].Value);\n        }\n        self.service.putObjectTagging(\n          {Tagging: {TagSet: self.tags}},\n          function(e, d) {\n            if (e) {\n              self.callback(e);\n            } else {\n              self.callback(e, data);\n            }\n          }\n        );\n      } else {\n        self.callback(err, data);\n      }\n    });\n  },\n\n  /**\n   * @api private\n   */\n  finishSinglePart: function finishSinglePart(err, data) {\n    var upload = this.request._managedUpload;\n    var httpReq = this.request.httpRequest;\n    var endpoint = httpReq.endpoint;\n    if (err) return upload.callback(err);\n    data.Location =\n      [endpoint.protocol, '//', endpoint.host, httpReq.path].join('');\n    data.key = this.request.params.Key; // will stay undocumented\n    data.Key = this.request.params.Key;\n    data.Bucket = this.request.params.Bucket;\n    upload.callback(err, data);\n  },\n\n  /**\n   * @api private\n   */\n  progress: function progress(info) {\n    var upload = this._managedUpload;\n    if (this.operation === 'putObject') {\n      info.part = 1;\n      info.key = this.params.Key;\n    } else {\n      upload.totalUploadedBytes += info.loaded - this._lastUploadedBytes;\n      this._lastUploadedBytes = info.loaded;\n      info = {\n        loaded: upload.totalUploadedBytes,\n        total: upload.totalBytes,\n        part: this.params.PartNumber,\n        key: this.params.Key\n      };\n    }\n    upload.emit('httpUploadProgress', [info]);\n  }\n});\n\nAWS.util.mixin(AWS.S3.ManagedUpload, AWS.SequentialExecutor);\n\n/**\n * @api private\n */\nAWS.S3.ManagedUpload.addPromisesToClass = function addPromisesToClass(PromiseDependency) {\n  this.prototype.promise = AWS.util.promisifyMethod('send', PromiseDependency);\n};\n\n/**\n * @api private\n */\nAWS.S3.ManagedUpload.deletePromisesFromClass = function deletePromisesFromClass() {\n  delete this.prototype.promise;\n};\n\nAWS.util.addPromises(AWS.S3.ManagedUpload);\n\n/**\n * @api private\n */\nmodule.exports = AWS.S3.ManagedUpload;\n"],"mappings":"AAAA,IAAIA,GAAG,GAAGC,OAAO,CAAC,SAAS,CAAC;AAC5B,IAAIC,UAAU,GAAGF,GAAG,CAACG,IAAI,CAACC,MAAM,CAACF,UAAU;AAC3C,IAAIG,MAAM,GAAGL,GAAG,CAACG,IAAI,CAACE,MAAM;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAL,GAAG,CAACM,EAAE,CAACC,aAAa,GAAGP,GAAG,CAACG,IAAI,CAACK,OAAO,CAAC;EACtC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,WAAW,EAAE,SAASF,aAAaA,CAACG,OAAO,EAAE;IAC3C,IAAIC,IAAI,GAAG,IAAI;IACfX,GAAG,CAACY,kBAAkB,CAACC,IAAI,CAACF,IAAI,CAAC;IACjCA,IAAI,CAACG,IAAI,GAAG,IAAI;IAChBH,IAAI,CAACI,OAAO,GAAG,IAAI;IACnBJ,IAAI,CAACK,QAAQ,GAAG,IAAI;IACpBL,IAAI,CAACM,KAAK,GAAG,CAAC,CAAC;IACfN,IAAI,CAACO,YAAY,GAAG,EAAE;IACtBP,IAAI,CAACQ,SAAS,GAAG,YAAW;MAC1BR,IAAI,CAACK,QAAQ,CAAC,IAAII,KAAK,CAAC,2BAA2B,GAAG,OAAOT,IAAI,CAACG,IAAI,CAAC,CAAC;IAC1E,CAAC;IAEDH,IAAI,CAACU,SAAS,CAACX,OAAO,CAAC;EACzB,CAAC;EAED;AACF;AACA;EACEW,SAAS,EAAE,SAASA,SAASA,CAACX,OAAO,EAAE;IACrCA,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;IACvB,IAAI,CAACY,QA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"},"metadata":{},"sourceType":"script","externalDependencies":[]}