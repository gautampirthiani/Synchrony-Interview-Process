{"ast":null,"code":"(function (exports) {\n  \"use strict\";\n\n  function isArray(obj) {\n    if (obj !== null) {\n      return Object.prototype.toString.call(obj) === \"[object Array]\";\n    } else {\n      return false;\n    }\n  }\n  function isObject(obj) {\n    if (obj !== null) {\n      return Object.prototype.toString.call(obj) === \"[object Object]\";\n    } else {\n      return false;\n    }\n  }\n  function strictDeepEqual(first, second) {\n    // Check the scalar case first.\n    if (first === second) {\n      return true;\n    }\n\n    // Check if they are the same type.\n    var firstType = Object.prototype.toString.call(first);\n    if (firstType !== Object.prototype.toString.call(second)) {\n      return false;\n    }\n    // We know that first and second have the same type so we can just check the\n    // first type from now on.\n    if (isArray(first) === true) {\n      // Short circuit if they're not the same length;\n      if (first.length !== second.length) {\n        return false;\n      }\n      for (var i = 0; i < first.length; i++) {\n        if (strictDeepEqual(first[i], second[i]) === false) {\n          return false;\n        }\n      }\n      return true;\n    }\n    if (isObject(first) === true) {\n      // An object is equal if it has the same key/value pairs.\n      var keysSeen = {};\n      for (var key in first) {\n        if (hasOwnProperty.call(first, key)) {\n          if (strictDeepEqual(first[key], second[key]) === false) {\n            return false;\n          }\n          keysSeen[key] = true;\n        }\n      }\n      // Now check that there aren't any keys in second that weren't\n      // in first.\n      for (var key2 in second) {\n        if (hasOwnProperty.call(second, key2)) {\n          if (keysSeen[key2] !== true) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n  function isFalse(obj) {\n    // From the spec:\n    // A false value corresponds to the following values:\n    // Empty list\n    // Empty object\n    // Empty string\n    // False boolean\n    // null value\n\n    // First check the scalar values.\n    if (obj === \"\" || obj === false || obj === null) {\n      return true;\n    } else if (isArray(obj) && obj.length === 0) {\n      // Check for an empty array.\n      return true;\n    } else if (isObject(obj)) {\n      // Check for an empty object.\n      for (var key in obj) {\n        // If there are any keys, then\n        // the object is not empty so the object\n        // is not false.\n        if (obj.hasOwnProperty(key)) {\n          return false;\n        }\n      }\n      return true;\n    } else {\n      return false;\n    }\n  }\n  function objValues(obj) {\n    var keys = Object.keys(obj);\n    var values = [];\n    for (var i = 0; i < keys.length; i++) {\n      values.push(obj[keys[i]]);\n    }\n    return values;\n  }\n  function merge(a, b) {\n    var merged = {};\n    for (var key in a) {\n      merged[key] = a[key];\n    }\n    for (var key2 in b) {\n      merged[key2] = b[key2];\n    }\n    return merged;\n  }\n  var trimLeft;\n  if (typeof String.prototype.trimLeft === \"function\") {\n    trimLeft = function (str) {\n      return str.trimLeft();\n    };\n  } else {\n    trimLeft = function (str) {\n      return str.match(/^\\s*(.*)/)[1];\n    };\n  }\n\n  // Type constants used to define functions.\n  var TYPE_NUMBER = 0;\n  var TYPE_ANY = 1;\n  var TYPE_STRING = 2;\n  var TYPE_ARRAY = 3;\n  var TYPE_OBJECT = 4;\n  var TYPE_BOOLEAN = 5;\n  var TYPE_EXPREF = 6;\n  var TYPE_NULL = 7;\n  var TYPE_ARRAY_NUMBER = 8;\n  var TYPE_ARRAY_STRING = 9;\n  var TYPE_NAME_TABLE = {\n    0: 'number',\n    1: 'any',\n    2: 'string',\n    3: 'array',\n    4: 'object',\n    5: 'boolean',\n    6: 'expression',\n    7: 'null',\n    8: 'Array<number>',\n    9: 'Array<string>'\n  };\n  var TOK_EOF = \"EOF\";\n  var TOK_UNQUOTEDIDENTIFIER = \"UnquotedIdentifier\";\n  var TOK_QUOTEDIDENTIFIER = \"QuotedIdentifier\";\n  var TOK_RBRACKET = \"Rbracket\";\n  var TOK_RPAREN = \"Rparen\";\n  var TOK_COMMA = \"Comma\";\n  var TOK_COLON = \"Colon\";\n  var TOK_RBRACE = \"Rbrace\";\n  var TOK_NUMBER = \"Number\";\n  var TOK_CURRENT = \"Current\";\n  var TOK_EXPREF = \"Expref\";\n  var TOK_PIPE = \"Pipe\";\n  var TOK_OR = \"Or\";\n  var TOK_AND = \"And\";\n  var TOK_EQ = \"EQ\";\n  var TOK_GT = \"GT\";\n  var TOK_LT = \"LT\";\n  var TOK_GTE = \"GTE\";\n  var TOK_LTE = \"LTE\";\n  var TOK_NE = \"NE\";\n  var TOK_FLATTEN = \"Flatten\";\n  var TOK_STAR = \"Star\";\n  var TOK_FILTER = \"Filter\";\n  var TOK_DOT = \"Dot\";\n  var TOK_NOT = \"Not\";\n  var TOK_LBRACE = \"Lbrace\";\n  var TOK_LBRACKET = \"Lbracket\";\n  var TOK_LPAREN = \"Lparen\";\n  var TOK_LITERAL = \"Literal\";\n\n  // The \"&\", \"[\", \"<\", \">\" tokens\n  // are not in basicToken because\n  // there are two token variants\n  // (\"&&\", \"[?\", \"<=\", \">=\").  This is specially handled\n  // below.\n\n  var basicTokens = {\n    \".\": TOK_DOT,\n    \"*\": TOK_STAR,\n    \",\": TOK_COMMA,\n    \":\": TOK_COLON,\n    \"{\": TOK_LBRACE,\n    \"}\": TOK_RBRACE,\n    \"]\": TOK_RBRACKET,\n    \"(\": TOK_LPAREN,\n    \")\": TOK_RPAREN,\n    \"@\": TOK_CURRENT\n  };\n  var operatorStartToken = {\n    \"<\": true,\n    \">\": true,\n    \"=\": true,\n    \"!\": true\n  };\n  var skipChars = {\n    \" \": true,\n    \"\\t\": true,\n    \"\\n\": true\n  };\n  function isAlpha(ch) {\n    return ch >= \"a\" && ch <= \"z\" || ch >= \"A\" && ch <= \"Z\" || ch === \"_\";\n  }\n  function isNum(ch) {\n    return ch >= \"0\" && ch <= \"9\" || ch === \"-\";\n  }\n  function isAlphaNum(ch) {\n    return ch >= \"a\" && ch <= \"z\" || ch >= \"A\" && ch <= \"Z\" || ch >= \"0\" && ch <= \"9\" || ch === \"_\";\n  }\n  function Lexer() {}\n  Lexer.prototype = {\n    tokenize: function (stream) {\n      var tokens = [];\n      this._current = 0;\n      var start;\n      var identifier;\n      var token;\n      while (this._current < stream.length) {\n        if (isAlpha(stream[this._current])) {\n          start = this._current;\n          identifier = this._consumeUnquotedIdentifier(stream);\n          tokens.push({\n            type: TOK_UNQUOTEDIDENTIFIER,\n            value: identifier,\n            start: start\n          });\n        } else if (basicTokens[stream[this._current]] !== undefined) {\n          tokens.push({\n            type: basicTokens[stream[this._current]],\n            value: stream[this._current],\n            start: this._current\n          });\n          this._current++;\n        } else if (isNum(stream[this._current])) {\n          token = this._consumeNumber(stream);\n          tokens.push(token);\n        } else if (stream[this._current] === \"[\") {\n          // No need to increment this._current.  This happens\n          // in _consumeLBracket\n          token = this._consumeLBracket(stream);\n          tokens.push(token);\n        } else if (stream[this._current] === \"\\\"\") {\n          start = this._current;\n          identifier = this._consumeQuotedIdentifier(stream);\n          tokens.push({\n            type: TOK_QUOTEDIDENTIFIER,\n            value: identifier,\n            start: start\n          });\n        } else if (stream[this._current] === \"'\") {\n          start = this._current;\n          identifier = this._consumeRawStringLiteral(stream);\n          tokens.push({\n            type: TOK_LITERAL,\n            value: identifier,\n            start: start\n          });\n        } else if (stream[this._current] === \"`\") {\n          start = this._current;\n          var literal = this._consumeLiteral(stream);\n          tokens.push({\n            type: TOK_LITERAL,\n            value: literal,\n            start: start\n          });\n        } else if (operatorStartToken[stream[this._current]] !== undefined) {\n          tokens.push(this._consumeOperator(stream));\n        } else if (skipChars[stream[this._current]] !== undefined) {\n          // Ignore whitespace.\n          this._current++;\n        } else if (stream[this._current] === \"&\") {\n          start = this._current;\n          this._current++;\n          if (stream[this._current] === \"&\") {\n            this._current++;\n            tokens.push({\n              type: TOK_AND,\n              value: \"&&\",\n              start: start\n            });\n          } else {\n            tokens.push({\n              type: TOK_EXPREF,\n              value: \"&\",\n              start: start\n            });\n          }\n        } else if (stream[this._current] === \"|\") {\n          start = this._current;\n          this._current++;\n          if (stream[this._current] === \"|\") {\n            this._current++;\n            tokens.push({\n              type: TOK_OR,\n              value: \"||\",\n              start: start\n            });\n          } else {\n            tokens.push({\n              type: TOK_PIPE,\n              value: \"|\",\n              start: start\n            });\n          }\n        } else {\n          var error = new Error(\"Unknown character:\" + stream[this._current]);\n          error.name = \"LexerError\";\n          throw error;\n        }\n      }\n      return tokens;\n    },\n    _consumeUnquotedIdentifier: function (stream) {\n      var start = this._current;\n      this._current++;\n      while (this._current < stream.length && isAlphaNum(stream[this._current])) {\n        this._current++;\n      }\n      return stream.slice(start, this._current);\n    },\n    _consumeQuotedIdentifier: function (stream) {\n      var start = this._current;\n      this._current++;\n      var maxLength = stream.length;\n      while (stream[this._current] !== \"\\\"\" && this._current < maxLength) {\n        // You can escape a double quote and you can escape an escape.\n        var current = this._current;\n        if (stream[current] === \"\\\\\" && (stream[current + 1] === \"\\\\\" || stream[current + 1] === \"\\\"\")) {\n          current += 2;\n        } else {\n          current++;\n        }\n        this._current = current;\n      }\n      this._current++;\n      return JSON.parse(stream.slice(start, this._current));\n    },\n    _consumeRawStringLiteral: function (stream) {\n      var start = this._current;\n      this._current++;\n      var maxLength = stream.length;\n      while (stream[this._current] !== \"'\" && this._current < maxLength) {\n        // You can escape a single quote and you can escape an escape.\n        var current = this._current;\n        if (stream[current] === \"\\\\\" && (stream[current + 1] === \"\\\\\" || stream[current + 1] === \"'\")) {\n          current += 2;\n        } else {\n          current++;\n        }\n        this._current = current;\n      }\n      this._current++;\n      var literal = stream.slice(start + 1, this._current - 1);\n      return literal.replace(\"\\\\'\", \"'\");\n    },\n    _consumeNumber: function (stream) {\n      var start = this._current;\n      this._current++;\n      var maxLength = stream.length;\n      while (isNum(stream[this._current]) && this._current < maxLength) {\n        this._current++;\n      }\n      var value = parseInt(stream.slice(start, this._current));\n      return {\n        type: TOK_NUMBER,\n        value: value,\n        start: start\n      };\n    },\n    _consumeLBracket: function (stream) {\n      var start = this._current;\n      this._current++;\n      if (stream[this._current] === \"?\") {\n        this._current++;\n        return {\n          type: TOK_FILTER,\n          value: \"[?\",\n          start: start\n        };\n      } else if (stream[this._current] === \"]\") {\n        this._current++;\n        return {\n          type: TOK_FLATTEN,\n          value: \"[]\",\n          start: start\n        };\n      } else {\n        return {\n          type: TOK_LBRACKET,\n          value: \"[\",\n          start: start\n        };\n      }\n    },\n    _consumeOperator: function (stream) {\n      var start = this._current;\n      var startingChar = stream[start];\n      this._current++;\n      if (startingChar === \"!\") {\n        if (stream[this._current] === \"=\") {\n          this._current++;\n          return {\n            type: TOK_NE,\n            value: \"!=\",\n            start: start\n          };\n        } else {\n          return {\n            type: TOK_NOT,\n            value: \"!\",\n            start: start\n          };\n        }\n      } else if (startingChar === \"<\") {\n        if (stream[this._current] === \"=\") {\n          this._current++;\n          return {\n            type: TOK_LTE,\n            value: \"<=\",\n            start: start\n          };\n        } else {\n          return {\n            type: TOK_LT,\n            value: \"<\",\n            start: start\n          };\n        }\n      } else if (startingChar === \">\") {\n        if (stream[this._current] === \"=\") {\n          this._current++;\n          return {\n            type: TOK_GTE,\n            value: \">=\",\n            start: start\n          };\n        } else {\n          return {\n            type: TOK_GT,\n            value: \">\",\n            start: start\n          };\n        }\n      } else if (startingChar === \"=\") {\n        if (stream[this._current] === \"=\") {\n          this._current++;\n          return {\n            type: TOK_EQ,\n            value: \"==\",\n            start: start\n          };\n        }\n      }\n    },\n    _consumeLiteral: function (stream) {\n      this._current++;\n      var start = this._current;\n      var maxLength = stream.length;\n      var literal;\n      while (stream[this._current] !== \"`\" && this._current < maxLength) {\n        // You can escape a literal char or you can escape the escape.\n        var current = this._current;\n        if (stream[current] === \"\\\\\" && (stream[current + 1] === \"\\\\\" || stream[current + 1] === \"`\")) {\n          current += 2;\n        } else {\n          current++;\n        }\n        this._current = current;\n      }\n      var literalString = trimLeft(stream.slice(start, this._current));\n      literalString = literalString.replace(\"\\\\`\", \"`\");\n      if (this._looksLikeJSON(literalString)) {\n        literal = JSON.parse(literalString);\n      } else {\n        // Try to JSON parse it as \"<literal>\"\n        literal = JSON.parse(\"\\\"\" + literalString + \"\\\"\");\n      }\n      // +1 gets us to the ending \"`\", +1 to move on to the next char.\n      this._current++;\n      return literal;\n    },\n    _looksLikeJSON: function (literalString) {\n      var startingChars = \"[{\\\"\";\n      var jsonLiterals = [\"true\", \"false\", \"null\"];\n      var numberLooking = \"-0123456789\";\n      if (literalString === \"\") {\n        return false;\n      } else if (startingChars.indexOf(literalString[0]) >= 0) {\n        return true;\n      } else if (jsonLiterals.indexOf(literalString) >= 0) {\n        return true;\n      } else if (numberLooking.indexOf(literalString[0]) >= 0) {\n        try {\n          JSON.parse(literalString);\n          return true;\n        } catch (ex) {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    }\n  };\n  var bindingPower = {};\n  bindingPower[TOK_EOF] = 0;\n  bindingPower[TOK_UNQUOTEDIDENTIFIER] = 0;\n  bindingPower[TOK_QUOTEDIDENTIFIER] = 0;\n  bindingPower[TOK_RBRACKET] = 0;\n  bindingPower[TOK_RPAREN] = 0;\n  bindingPower[TOK_COMMA] = 0;\n  bindingPower[TOK_RBRACE] = 0;\n  bindingPower[TOK_NUMBER] = 0;\n  bindingPower[TOK_CURRENT] = 0;\n  bindingPower[TOK_EXPREF] = 0;\n  bindingPower[TOK_PIPE] = 1;\n  bindingPower[TOK_OR] = 2;\n  bindingPower[TOK_AND] = 3;\n  bindingPower[TOK_EQ] = 5;\n  bindingPower[TOK_GT] = 5;\n  bindingPower[TOK_LT] = 5;\n  bindingPower[TOK_GTE] = 5;\n  bindingPower[TOK_LTE] = 5;\n  bindingPower[TOK_NE] = 5;\n  bindingPower[TOK_FLATTEN] = 9;\n  bindingPower[TOK_STAR] = 20;\n  bindingPower[TOK_FILTER] = 21;\n  bindingPower[TOK_DOT] = 40;\n  bindingPower[TOK_NOT] = 45;\n  bindingPower[TOK_LBRACE] = 50;\n  bindingPower[TOK_LBRACKET] = 55;\n  bindingPower[TOK_LPAREN] = 60;\n  function Parser() {}\n  Parser.prototype = {\n    parse: function (expression) {\n      this._loadTokens(expression);\n      this.index = 0;\n      var ast = this.expression(0);\n      if (this._lookahead(0) !== TOK_EOF) {\n        var t = this._lookaheadToken(0);\n        var error = new Error(\"Unexpected token type: \" + t.type + \", value: \" + t.value);\n        error.name = \"ParserError\";\n        throw error;\n      }\n      return ast;\n    },\n    _loadTokens: function (expression) {\n      var lexer = new Lexer();\n      var tokens = lexer.tokenize(expression);\n      tokens.push({\n        type: TOK_EOF,\n        value: \"\",\n        start: expression.length\n      });\n      this.tokens = tokens;\n    },\n    expression: function (rbp) {\n      var leftToken = this._lookaheadToken(0);\n      this._advance();\n      var left = this.nud(leftToken);\n      var currentToken = this._lookahead(0);\n      while (rbp < bindingPower[currentToken]) {\n        this._advance();\n        left = this.led(currentToken, left);\n        currentToken = this._lookahead(0);\n      }\n      return left;\n    },\n    _lookahead: function (number) {\n      return this.tokens[this.index + number].type;\n    },\n    _lookaheadToken: function (number) {\n      return this.tokens[this.index + number];\n    },\n    _advance: function () {\n      this.index++;\n    },\n    nud: function (token) {\n      var left;\n      var right;\n      var expression;\n      switch (token.type) {\n        case TOK_LITERAL:\n          return {\n            type: \"Literal\",\n            value: token.value\n          };\n        case TOK_UNQUOTEDIDENTIFIER:\n          return {\n            type: \"Field\",\n            name: token.value\n          };\n        case TOK_QUOTEDIDENTIFIER:\n          var node = {\n            type: \"Field\",\n            name: token.value\n          };\n          if (this._lookahead(0) === TOK_LPAREN) {\n            throw new Error(\"Quoted identifier not allowed for function names.\");\n          }\n          return node;\n        case TOK_NOT:\n          right = this.expression(bindingPower.Not);\n          return {\n            type: \"NotExpression\",\n            children: [right]\n          };\n        case TOK_STAR:\n          left = {\n            type: \"Identity\"\n          };\n          right = null;\n          if (this._lookahead(0) === TOK_RBRACKET) {\n            // This can happen in a multiselect,\n            // [a, b, *]\n            right = {\n              type: \"Identity\"\n            };\n          } else {\n            right = this._parseProjectionRHS(bindingPower.Star);\n          }\n          return {\n            type: \"ValueProjection\",\n            children: [left, right]\n          };\n        case TOK_FILTER:\n          return this.led(token.type, {\n            type: \"Identity\"\n          });\n        case TOK_LBRACE:\n          return this._parseMultiselectHash();\n        case TOK_FLATTEN:\n          left = {\n            type: TOK_FLATTEN,\n            children: [{\n              type: \"Identity\"\n            }]\n          };\n          right = this._parseProjectionRHS(bindingPower.Flatten);\n          return {\n            type: \"Projection\",\n            children: [left, right]\n          };\n        case TOK_LBRACKET:\n          if (this._lookahead(0) === TOK_NUMBER || this._lookahead(0) === TOK_COLON) {\n            right = this._parseIndexExpression();\n            return this._projectIfSlice({\n              type: \"Identity\"\n            }, right);\n          } else if (this._lookahead(0) === TOK_STAR && this._lookahead(1) === TOK_RBRACKET) {\n            this._advance();\n            this._advance();\n            right = this._parseProjectionRHS(bindingPower.Star);\n            return {\n              type: \"Projection\",\n              children: [{\n                type: \"Identity\"\n              }, right]\n            };\n          }\n          return this._parseMultiselectList();\n        case TOK_CURRENT:\n          return {\n            type: TOK_CURRENT\n          };\n        case TOK_EXPREF:\n          expression = this.expression(bindingPower.Expref);\n          return {\n            type: \"ExpressionReference\",\n            children: [expression]\n          };\n        case TOK_LPAREN:\n          var args = [];\n          while (this._lookahead(0) !== TOK_RPAREN) {\n            if (this._lookahead(0) === TOK_CURRENT) {\n              expression = {\n                type: TOK_CURRENT\n              };\n              this._advance();\n            } else {\n              expression = this.expression(0);\n            }\n            args.push(expression);\n          }\n          this._match(TOK_RPAREN);\n          return args[0];\n        default:\n          this._errorToken(token);\n      }\n    },\n    led: function (tokenName, left) {\n      var right;\n      switch (tokenName) {\n        case TOK_DOT:\n          var rbp = bindingPower.Dot;\n          if (this._lookahead(0) !== TOK_STAR) {\n            right = this._parseDotRHS(rbp);\n            return {\n              type: \"Subexpression\",\n              children: [left, right]\n            };\n          }\n          // Creating a projection.\n          this._advance();\n          right = this._parseProjectionRHS(rbp);\n          return {\n            type: \"ValueProjection\",\n            children: [left, right]\n          };\n        case TOK_PIPE:\n          right = this.expression(bindingPower.Pipe);\n          return {\n            type: TOK_PIPE,\n            children: [left, right]\n          };\n        case TOK_OR:\n          right = this.expression(bindingPower.Or);\n          return {\n            type: \"OrExpression\",\n            children: [left, right]\n          };\n        case TOK_AND:\n          right = this.expression(bindingPower.And);\n          return {\n            type: \"AndExpression\",\n            children: [left, right]\n          };\n        case TOK_LPAREN:\n          var name = left.name;\n          var args = [];\n          var expression, node;\n          while (this._lookahead(0) !== TOK_RPAREN) {\n            if (this._lookahead(0) === TOK_CURRENT) {\n              expression = {\n                type: TOK_CURRENT\n              };\n              this._advance();\n            } else {\n              expression = this.expression(0);\n            }\n            if (this._lookahead(0) === TOK_COMMA) {\n              this._match(TOK_COMMA);\n            }\n            args.push(expression);\n          }\n          this._match(TOK_RPAREN);\n          node = {\n            type: \"Function\",\n            name: name,\n            children: args\n          };\n          return node;\n        case TOK_FILTER:\n          var condition = this.expression(0);\n          this._match(TOK_RBRACKET);\n          if (this._lookahead(0) === TOK_FLATTEN) {\n            right = {\n              type: \"Identity\"\n            };\n          } else {\n            right = this._parseProjectionRHS(bindingPower.Filter);\n          }\n          return {\n            type: \"FilterProjection\",\n            children: [left, right, condition]\n          };\n        case TOK_FLATTEN:\n          var leftNode = {\n            type: TOK_FLATTEN,\n            children: [left]\n          };\n          var rightNode = this._parseProjectionRHS(bindingPower.Flatten);\n          return {\n            type: \"Projection\",\n            children: [leftNode, rightNode]\n          };\n        case TOK_EQ:\n        case TOK_NE:\n        case TOK_GT:\n        case TOK_GTE:\n        case TOK_LT:\n        case TOK_LTE:\n          return this._parseComparator(left, tokenName);\n        case TOK_LBRACKET:\n          var token = this._lookaheadToken(0);\n          if (token.type === TOK_NUMBER || token.type === TOK_COLON) {\n            right = this._parseIndexExpression();\n            return this._projectIfSlice(left, right);\n          }\n          this._match(TOK_STAR);\n          this._match(TOK_RBRACKET);\n          right = this._parseProjectionRHS(bindingPower.Star);\n          return {\n            type: \"Projection\",\n            children: [left, right]\n          };\n        default:\n          this._errorToken(this._lookaheadToken(0));\n      }\n    },\n    _match: function (tokenType) {\n      if (this._lookahead(0) === tokenType) {\n        this._advance();\n      } else {\n        var t = this._lookaheadToken(0);\n        var error = new Error(\"Expected \" + tokenType + \", got: \" + t.type);\n        error.name = \"ParserError\";\n        throw error;\n      }\n    },\n    _errorToken: function (token) {\n      var error = new Error(\"Invalid token (\" + token.type + \"): \\\"\" + token.value + \"\\\"\");\n      error.name = \"ParserError\";\n      throw error;\n    },\n    _parseIndexExpression: function () {\n      if (this._lookahead(0) === TOK_COLON || this._lookahead(1) === TOK_COLON) {\n        return this._parseSliceExpression();\n      } else {\n        var node = {\n          type: \"Index\",\n          value: this._lookaheadToken(0).value\n        };\n        this._advance();\n        this._match(TOK_RBRACKET);\n        return node;\n      }\n    },\n    _projectIfSlice: function (left, right) {\n      var indexExpr = {\n        type: \"IndexExpression\",\n        children: [left, right]\n      };\n      if (right.type === \"Slice\") {\n        return {\n          type: \"Projection\",\n          children: [indexExpr, this._parseProjectionRHS(bindingPower.Star)]\n        };\n      } else {\n        return indexExpr;\n      }\n    },\n    _parseSliceExpression: function () {\n      // [start:end:step] where each part is optional, as well as the last\n      // colon.\n      var parts = [null, null, null];\n      var index = 0;\n      var currentToken = this._lookahead(0);\n      while (currentToken !== TOK_RBRACKET && index < 3) {\n        if (currentToken === TOK_COLON) {\n          index++;\n          this._advance();\n        } else if (currentToken === TOK_NUMBER) {\n          parts[index] = this._lookaheadToken(0).value;\n          this._advance();\n        } else {\n          var t = this._lookahead(0);\n          var error = new Error(\"Syntax error, unexpected token: \" + t.value + \"(\" + t.type + \")\");\n          error.name = \"Parsererror\";\n          throw error;\n        }\n        currentToken = this._lookahead(0);\n      }\n      this._match(TOK_RBRACKET);\n      return {\n        type: \"Slice\",\n        children: parts\n      };\n    },\n    _parseComparator: function (left, comparator) {\n      var right = this.expression(bindingPower[comparator]);\n      return {\n        type: \"Comparator\",\n        name: comparator,\n        children: [left, right]\n      };\n    },\n    _parseDotRHS: function (rbp) {\n      var lookahead = this._lookahead(0);\n      var exprTokens = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER, TOK_STAR];\n      if (exprTokens.indexOf(lookahead) >= 0) {\n        return this.expression(rbp);\n      } else if (lookahead === TOK_LBRACKET) {\n        this._match(TOK_LBRACKET);\n        return this._parseMultiselectList();\n      } else if (lookahead === TOK_LBRACE) {\n        this._match(TOK_LBRACE);\n        return this._parseMultiselectHash();\n      }\n    },\n    _parseProjectionRHS: function (rbp) {\n      var right;\n      if (bindingPower[this._lookahead(0)] < 10) {\n        right = {\n          type: \"Identity\"\n        };\n      } else if (this._lookahead(0) === TOK_LBRACKET) {\n        right = this.expression(rbp);\n      } else if (this._lookahead(0) === TOK_FILTER) {\n        right = this.expression(rbp);\n      } else if (this._lookahead(0) === TOK_DOT) {\n        this._match(TOK_DOT);\n        right = this._parseDotRHS(rbp);\n      } else {\n        var t = this._lookaheadToken(0);\n        var error = new Error(\"Sytanx error, unexpected token: \" + t.value + \"(\" + t.type + \")\");\n        error.name = \"ParserError\";\n        throw error;\n      }\n      return right;\n    },\n    _parseMultiselectList: function () {\n      var expressions = [];\n      while (this._lookahead(0) !== TOK_RBRACKET) {\n        var expression = this.expression(0);\n        expressions.push(expression);\n        if (this._lookahead(0) === TOK_COMMA) {\n          this._match(TOK_COMMA);\n          if (this._lookahead(0) === TOK_RBRACKET) {\n            throw new Error(\"Unexpected token Rbracket\");\n          }\n        }\n      }\n      this._match(TOK_RBRACKET);\n      return {\n        type: \"MultiSelectList\",\n        children: expressions\n      };\n    },\n    _parseMultiselectHash: function () {\n      var pairs = [];\n      var identifierTypes = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER];\n      var keyToken, keyName, value, node;\n      for (;;) {\n        keyToken = this._lookaheadToken(0);\n        if (identifierTypes.indexOf(keyToken.type) < 0) {\n          throw new Error(\"Expecting an identifier token, got: \" + keyToken.type);\n        }\n        keyName = keyToken.value;\n        this._advance();\n        this._match(TOK_COLON);\n        value = this.expression(0);\n        node = {\n          type: \"KeyValuePair\",\n          name: keyName,\n          value: value\n        };\n        pairs.push(node);\n        if (this._lookahead(0) === TOK_COMMA) {\n          this._match(TOK_COMMA);\n        } else if (this._lookahead(0) === TOK_RBRACE) {\n          this._match(TOK_RBRACE);\n          break;\n        }\n      }\n      return {\n        type: \"MultiSelectHash\",\n        children: pairs\n      };\n    }\n  };\n  function TreeInterpreter(runtime) {\n    this.runtime = runtime;\n  }\n  TreeInterpreter.prototype = {\n    search: function (node, value) {\n      return this.visit(node, value);\n    },\n    visit: function (node, value) {\n      var matched, current, result, first, second, field, left, right, collected, i;\n      switch (node.type) {\n        case \"Field\":\n          if (value !== null && isObject(value)) {\n            field = value[node.name];\n            if (field === undefined) {\n              return null;\n            } else {\n              return field;\n            }\n          }\n          return null;\n        case \"Subexpression\":\n          result = this.visit(node.children[0], value);\n          for (i = 1; i < node.children.length; i++) {\n            result = this.visit(node.children[1], result);\n            if (result === null) {\n              return null;\n            }\n          }\n          return result;\n        case \"IndexExpression\":\n          left = this.visit(node.children[0], value);\n          right = this.visit(node.children[1], left);\n          return right;\n        case \"Index\":\n          if (!isArray(value)) {\n            return null;\n          }\n          var index = node.value;\n          if (index < 0) {\n            index = value.length + index;\n          }\n          result = value[index];\n          if (result === undefined) {\n            result = null;\n          }\n          return result;\n        case \"Slice\":\n          if (!isArray(value)) {\n            return null;\n          }\n          var sliceParams = node.children.slice(0);\n          var computed = this.computeSliceParams(value.length, sliceParams);\n          var start = computed[0];\n          var stop = computed[1];\n          var step = computed[2];\n          result = [];\n          if (step > 0) {\n            for (i = start; i < stop; i += step) {\n              result.push(value[i]);\n            }\n          } else {\n            for (i = start; i > stop; i += step) {\n              result.push(value[i]);\n            }\n          }\n          return result;\n        case \"Projection\":\n          // Evaluate left child.\n          var base = this.visit(node.children[0], value);\n          if (!isArray(base)) {\n            return null;\n          }\n          collected = [];\n          for (i = 0; i < base.length; i++) {\n            current = this.visit(node.children[1], base[i]);\n            if (current !== null) {\n              collected.push(current);\n            }\n          }\n          return collected;\n        case \"ValueProjection\":\n          // Evaluate left child.\n          base = this.visit(node.children[0], value);\n          if (!isObject(base)) {\n            return null;\n          }\n          collected = [];\n          var values = objValues(base);\n          for (i = 0; i < values.length; i++) {\n            current = this.visit(node.children[1], values[i]);\n            if (current !== null) {\n              collected.push(current);\n            }\n          }\n          return collected;\n        case \"FilterProjection\":\n          base = this.visit(node.children[0], value);\n          if (!isArray(base)) {\n            return null;\n          }\n          var filtered = [];\n          var finalResults = [];\n          for (i = 0; i < base.length; i++) {\n            matched = this.visit(node.children[2], base[i]);\n            if (!isFalse(matched)) {\n              filtered.push(base[i]);\n            }\n          }\n          for (var j = 0; j < filtered.length; j++) {\n            current = this.visit(node.children[1], filtered[j]);\n            if (current !== null) {\n              finalResults.push(current);\n            }\n          }\n          return finalResults;\n        case \"Comparator\":\n          first = this.visit(node.children[0], value);\n          second = this.visit(node.children[1], value);\n          switch (node.name) {\n            case TOK_EQ:\n              result = strictDeepEqual(first, second);\n              break;\n            case TOK_NE:\n              result = !strictDeepEqual(first, second);\n              break;\n            case TOK_GT:\n              result = first > second;\n              break;\n            case TOK_GTE:\n              result = first >= second;\n              break;\n            case TOK_LT:\n              result = first < second;\n              break;\n            case TOK_LTE:\n              result = first <= second;\n              break;\n            default:\n              throw new Error(\"Unknown comparator: \" + node.name);\n          }\n          return result;\n        case TOK_FLATTEN:\n          var original = this.visit(node.children[0], value);\n          if (!isArray(original)) {\n            return null;\n          }\n          var merged = [];\n          for (i = 0; i < original.length; i++) {\n            current = original[i];\n            if (isArray(current)) {\n              merged.push.apply(merged, current);\n            } else {\n              merged.push(current);\n            }\n          }\n          return merged;\n        case \"Identity\":\n          return value;\n        case \"MultiSelectList\":\n          if (value === null) {\n            return null;\n          }\n          collected = [];\n          for (i = 0; i < node.children.length; i++) {\n            collected.push(this.visit(node.children[i], value));\n          }\n          return collected;\n        case \"MultiSelectHash\":\n          if (value === null) {\n            return null;\n          }\n          collected = {};\n          var child;\n          for (i = 0; i < node.children.length; i++) {\n            child = node.children[i];\n            collected[child.name] = this.visit(child.value, value);\n          }\n          return collected;\n        case \"OrExpression\":\n          matched = this.visit(node.children[0], value);\n          if (isFalse(matched)) {\n            matched = this.visit(node.children[1], value);\n          }\n          return matched;\n        case \"AndExpression\":\n          first = this.visit(node.children[0], value);\n          if (isFalse(first) === true) {\n            return first;\n          }\n          return this.visit(node.children[1], value);\n        case \"NotExpression\":\n          first = this.visit(node.children[0], value);\n          return isFalse(first);\n        case \"Literal\":\n          return node.value;\n        case TOK_PIPE:\n          left = this.visit(node.children[0], value);\n          return this.visit(node.children[1], left);\n        case TOK_CURRENT:\n          return value;\n        case \"Function\":\n          var resolvedArgs = [];\n          for (i = 0; i < node.children.length; i++) {\n            resolvedArgs.push(this.visit(node.children[i], value));\n          }\n          return this.runtime.callFunction(node.name, resolvedArgs);\n        case \"ExpressionReference\":\n          var refNode = node.children[0];\n          // Tag the node with a specific attribute so the type\n          // checker verify the type.\n          refNode.jmespathType = TOK_EXPREF;\n          return refNode;\n        default:\n          throw new Error(\"Unknown node type: \" + node.type);\n      }\n    },\n    computeSliceParams: function (arrayLength, sliceParams) {\n      var start = sliceParams[0];\n      var stop = sliceParams[1];\n      var step = sliceParams[2];\n      var computed = [null, null, null];\n      if (step === null) {\n        step = 1;\n      } else if (step === 0) {\n        var error = new Error(\"Invalid slice, step cannot be 0\");\n        error.name = \"RuntimeError\";\n        throw error;\n      }\n      var stepValueNegative = step < 0 ? true : false;\n      if (start === null) {\n        start = stepValueNegative ? arrayLength - 1 : 0;\n      } else {\n        start = this.capSliceRange(arrayLength, start, step);\n      }\n      if (stop === null) {\n        stop = stepValueNegative ? -1 : arrayLength;\n      } else {\n        stop = this.capSliceRange(arrayLength, stop, step);\n      }\n      computed[0] = start;\n      computed[1] = stop;\n      computed[2] = step;\n      return computed;\n    },\n    capSliceRange: function (arrayLength, actualValue, step) {\n      if (actualValue < 0) {\n        actualValue += arrayLength;\n        if (actualValue < 0) {\n          actualValue = step < 0 ? -1 : 0;\n        }\n      } else if (actualValue >= arrayLength) {\n        actualValue = step < 0 ? arrayLength - 1 : arrayLength;\n      }\n      return actualValue;\n    }\n  };\n  function Runtime(interpreter) {\n    this._interpreter = interpreter;\n    this.functionTable = {\n      // name: [function, <signature>]\n      // The <signature> can be:\n      //\n      // {\n      //   args: [[type1, type2], [type1, type2]],\n      //   variadic: true|false\n      // }\n      //\n      // Each arg in the arg list is a list of valid types\n      // (if the function is overloaded and supports multiple\n      // types.  If the type is \"any\" then no type checking\n      // occurs on the argument.  Variadic is optional\n      // and if not provided is assumed to be false.\n      abs: {\n        _func: this._functionAbs,\n        _signature: [{\n          types: [TYPE_NUMBER]\n        }]\n      },\n      avg: {\n        _func: this._functionAvg,\n        _signature: [{\n          types: [TYPE_ARRAY_NUMBER]\n        }]\n      },\n      ceil: {\n        _func: this._functionCeil,\n        _signature: [{\n          types: [TYPE_NUMBER]\n        }]\n      },\n      contains: {\n        _func: this._functionContains,\n        _signature: [{\n          types: [TYPE_STRING, TYPE_ARRAY]\n        }, {\n          types: [TYPE_ANY]\n        }]\n      },\n      \"ends_with\": {\n        _func: this._functionEndsWith,\n        _signature: [{\n          types: [TYPE_STRING]\n        }, {\n          types: [TYPE_STRING]\n        }]\n      },\n      floor: {\n        _func: this._functionFloor,\n        _signature: [{\n          types: [TYPE_NUMBER]\n        }]\n      },\n      length: {\n        _func: this._functionLength,\n        _signature: [{\n          types: [TYPE_STRING, TYPE_ARRAY, TYPE_OBJECT]\n        }]\n      },\n      map: {\n        _func: this._functionMap,\n        _signature: [{\n          types: [TYPE_EXPREF]\n        }, {\n          types: [TYPE_ARRAY]\n        }]\n      },\n      max: {\n        _func: this._functionMax,\n        _signature: [{\n          types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]\n        }]\n      },\n      \"merge\": {\n        _func: this._functionMerge,\n        _signature: [{\n          types: [TYPE_OBJECT],\n          variadic: true\n        }]\n      },\n      \"max_by\": {\n        _func: this._functionMaxBy,\n        _signature: [{\n          types: [TYPE_ARRAY]\n        }, {\n          types: [TYPE_EXPREF]\n        }]\n      },\n      sum: {\n        _func: this._functionSum,\n        _signature: [{\n          types: [TYPE_ARRAY_NUMBER]\n        }]\n      },\n      \"starts_with\": {\n        _func: this._functionStartsWith,\n        _signature: [{\n          types: [TYPE_STRING]\n        }, {\n          types: [TYPE_STRING]\n        }]\n      },\n      min: {\n        _func: this._functionMin,\n        _signature: [{\n          types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]\n        }]\n      },\n      \"min_by\": {\n        _func: this._functionMinBy,\n        _signature: [{\n          types: [TYPE_ARRAY]\n        }, {\n          types: [TYPE_EXPREF]\n        }]\n      },\n      type: {\n        _func: this._functionType,\n        _signature: [{\n          types: [TYPE_ANY]\n        }]\n      },\n      keys: {\n        _func: this._functionKeys,\n        _signature: [{\n          types: [TYPE_OBJECT]\n        }]\n      },\n      values: {\n        _func: this._functionValues,\n        _signature: [{\n          types: [TYPE_OBJECT]\n        }]\n      },\n      sort: {\n        _func: this._functionSort,\n        _signature: [{\n          types: [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER]\n        }]\n      },\n      \"sort_by\": {\n        _func: this._functionSortBy,\n        _signature: [{\n          types: [TYPE_ARRAY]\n        }, {\n          types: [TYPE_EXPREF]\n        }]\n      },\n      join: {\n        _func: this._functionJoin,\n        _signature: [{\n          types: [TYPE_STRING]\n        }, {\n          types: [TYPE_ARRAY_STRING]\n        }]\n      },\n      reverse: {\n        _func: this._functionReverse,\n        _signature: [{\n          types: [TYPE_STRING, TYPE_ARRAY]\n        }]\n      },\n      \"to_array\": {\n        _func: this._functionToArray,\n        _signature: [{\n          types: [TYPE_ANY]\n        }]\n      },\n      \"to_string\": {\n        _func: this._functionToString,\n        _signature: [{\n          types: [TYPE_ANY]\n        }]\n      },\n      \"to_number\": {\n        _func: this._functionToNumber,\n        _signature: [{\n          types: [TYPE_ANY]\n        }]\n      },\n      \"not_null\": {\n        _func: this._functionNotNull,\n        _signature: [{\n          types: [TYPE_ANY],\n          variadic: true\n        }]\n      }\n    };\n  }\n  Runtime.prototype = {\n    callFunction: function (name, resolvedArgs) {\n      var functionEntry = this.functionTable[name];\n      if (functionEntry === undefined) {\n        throw new Error(\"Unknown function: \" + name + \"()\");\n      }\n      this._validateArgs(name, resolvedArgs, functionEntry._signature);\n      return functionEntry._func.call(this, resolvedArgs);\n    },\n    _validateArgs: function (name, args, signature) {\n      // Validating the args requires validating\n      // the correct arity and the correct type of each arg.\n      // If the last argument is declared as variadic, then we need\n      // a minimum number of args to be required.  Otherwise it has to\n      // be an exact amount.\n      var pluralized;\n      if (signature[signature.length - 1].variadic) {\n        if (args.length < signature.length) {\n          pluralized = signature.length === 1 ? \" argument\" : \" arguments\";\n          throw new Error(\"ArgumentError: \" + name + \"() \" + \"takes at least\" + signature.length + pluralized + \" but received \" + args.length);\n        }\n      } else if (args.length !== signature.length) {\n        pluralized = signature.length === 1 ? \" argument\" : \" arguments\";\n        throw new Error(\"ArgumentError: \" + name + \"() \" + \"takes \" + signature.length + pluralized + \" but received \" + args.length);\n      }\n      var currentSpec;\n      var actualType;\n      var typeMatched;\n      for (var i = 0; i < signature.length; i++) {\n        typeMatched = false;\n        currentSpec = signature[i].types;\n        actualType = this._getTypeName(args[i]);\n        for (var j = 0; j < currentSpec.length; j++) {\n          if (this._typeMatches(actualType, currentSpec[j], args[i])) {\n            typeMatched = true;\n            break;\n          }\n        }\n        if (!typeMatched) {\n          var expected = currentSpec.map(function (typeIdentifier) {\n            return TYPE_NAME_TABLE[typeIdentifier];\n          }).join(',');\n          throw new Error(\"TypeError: \" + name + \"() \" + \"expected argument \" + (i + 1) + \" to be type \" + expected + \" but received type \" + TYPE_NAME_TABLE[actualType] + \" instead.\");\n        }\n      }\n    },\n    _typeMatches: function (actual, expected, argValue) {\n      if (expected === TYPE_ANY) {\n        return true;\n      }\n      if (expected === TYPE_ARRAY_STRING || expected === TYPE_ARRAY_NUMBER || expected === TYPE_ARRAY) {\n        // The expected type can either just be array,\n        // or it can require a specific subtype (array of numbers).\n        //\n        // The simplest case is if \"array\" with no subtype is specified.\n        if (expected === TYPE_ARRAY) {\n          return actual === TYPE_ARRAY;\n        } else if (actual === TYPE_ARRAY) {\n          // Otherwise we need to check subtypes.\n          // I think this has potential to be improved.\n          var subtype;\n          if (expected === TYPE_ARRAY_NUMBER) {\n            subtype = TYPE_NUMBER;\n          } else if (expected === TYPE_ARRAY_STRING) {\n            subtype = TYPE_STRING;\n          }\n          for (var i = 0; i < argValue.length; i++) {\n            if (!this._typeMatches(this._getTypeName(argValue[i]), subtype, argValue[i])) {\n              return false;\n            }\n          }\n          return true;\n        }\n      } else {\n        return actual === expected;\n      }\n    },\n    _getTypeName: function (obj) {\n      switch (Object.prototype.toString.call(obj)) {\n        case \"[object String]\":\n          return TYPE_STRING;\n        case \"[object Number]\":\n          return TYPE_NUMBER;\n        case \"[object Array]\":\n          return TYPE_ARRAY;\n        case \"[object Boolean]\":\n          return TYPE_BOOLEAN;\n        case \"[object Null]\":\n          return TYPE_NULL;\n        case \"[object Object]\":\n          // Check if it's an expref.  If it has, it's been\n          // tagged with a jmespathType attr of 'Expref';\n          if (obj.jmespathType === TOK_EXPREF) {\n            return TYPE_EXPREF;\n          } else {\n            return TYPE_OBJECT;\n          }\n      }\n    },\n    _functionStartsWith: function (resolvedArgs) {\n      return resolvedArgs[0].lastIndexOf(resolvedArgs[1]) === 0;\n    },\n    _functionEndsWith: function (resolvedArgs) {\n      var searchStr = resolvedArgs[0];\n      var suffix = resolvedArgs[1];\n      return searchStr.indexOf(suffix, searchStr.length - suffix.length) !== -1;\n    },\n    _functionReverse: function (resolvedArgs) {\n      var typeName = this._getTypeName(resolvedArgs[0]);\n      if (typeName === TYPE_STRING) {\n        var originalStr = resolvedArgs[0];\n        var reversedStr = \"\";\n        for (var i = originalStr.length - 1; i >= 0; i--) {\n          reversedStr += originalStr[i];\n        }\n        return reversedStr;\n      } else {\n        var reversedArray = resolvedArgs[0].slice(0);\n        reversedArray.reverse();\n        return reversedArray;\n      }\n    },\n    _functionAbs: function (resolvedArgs) {\n      return Math.abs(resolvedArgs[0]);\n    },\n    _functionCeil: function (resolvedArgs) {\n      return Math.ceil(resolvedArgs[0]);\n    },\n    _functionAvg: function (resolvedArgs) {\n      var sum = 0;\n      var inputArray = resolvedArgs[0];\n      for (var i = 0; i < inputArray.length; i++) {\n        sum += inputArray[i];\n      }\n      return sum / inputArray.length;\n    },\n    _functionContains: function (resolvedArgs) {\n      return resolvedArgs[0].indexOf(resolvedArgs[1]) >= 0;\n    },\n    _functionFloor: function (resolvedArgs) {\n      return Math.floor(resolvedArgs[0]);\n    },\n    _functionLength: function (resolvedArgs) {\n      if (!isObject(resolvedArgs[0])) {\n        return resolvedArgs[0].length;\n      } else {\n        // As far as I can tell, there's no way to get the length\n        // of an object without O(n) iteration through the object.\n        return Object.keys(resolvedArgs[0]).length;\n      }\n    },\n    _functionMap: function (resolvedArgs) {\n      var mapped = [];\n      var interpreter = this._interpreter;\n      var exprefNode = resolvedArgs[0];\n      var elements = resolvedArgs[1];\n      for (var i = 0; i < elements.length; i++) {\n        mapped.push(interpreter.visit(exprefNode, elements[i]));\n      }\n      return mapped;\n    },\n    _functionMerge: function (resolvedArgs) {\n      var merged = {};\n      for (var i = 0; i < resolvedArgs.length; i++) {\n        var current = resolvedArgs[i];\n        for (var key in current) {\n          merged[key] = current[key];\n        }\n      }\n      return merged;\n    },\n    _functionMax: function (resolvedArgs) {\n      if (resolvedArgs[0].length > 0) {\n        var typeName = this._getTypeName(resolvedArgs[0][0]);\n        if (typeName === TYPE_NUMBER) {\n          return Math.max.apply(Math, resolvedArgs[0]);\n        } else {\n          var elements = resolvedArgs[0];\n          var maxElement = elements[0];\n          for (var i = 1; i < elements.length; i++) {\n            if (maxElement.localeCompare(elements[i]) < 0) {\n              maxElement = elements[i];\n            }\n          }\n          return maxElement;\n        }\n      } else {\n        return null;\n      }\n    },\n    _functionMin: function (resolvedArgs) {\n      if (resolvedArgs[0].length > 0) {\n        var typeName = this._getTypeName(resolvedArgs[0][0]);\n        if (typeName === TYPE_NUMBER) {\n          return Math.min.apply(Math, resolvedArgs[0]);\n        } else {\n          var elements = resolvedArgs[0];\n          var minElement = elements[0];\n          for (var i = 1; i < elements.length; i++) {\n            if (elements[i].localeCompare(minElement) < 0) {\n              minElement = elements[i];\n            }\n          }\n          return minElement;\n        }\n      } else {\n        return null;\n      }\n    },\n    _functionSum: function (resolvedArgs) {\n      var sum = 0;\n      var listToSum = resolvedArgs[0];\n      for (var i = 0; i < listToSum.length; i++) {\n        sum += listToSum[i];\n      }\n      return sum;\n    },\n    _functionType: function (resolvedArgs) {\n      switch (this._getTypeName(resolvedArgs[0])) {\n        case TYPE_NUMBER:\n          return \"number\";\n        case TYPE_STRING:\n          return \"string\";\n        case TYPE_ARRAY:\n          return \"array\";\n        case TYPE_OBJECT:\n          return \"object\";\n        case TYPE_BOOLEAN:\n          return \"boolean\";\n        case TYPE_EXPREF:\n          return \"expref\";\n        case TYPE_NULL:\n          return \"null\";\n      }\n    },\n    _functionKeys: function (resolvedArgs) {\n      return Object.keys(resolvedArgs[0]);\n    },\n    _functionValues: function (resolvedArgs) {\n      var obj = resolvedArgs[0];\n      var keys = Object.keys(obj);\n      var values = [];\n      for (var i = 0; i < keys.length; i++) {\n        values.push(obj[keys[i]]);\n      }\n      return values;\n    },\n    _functionJoin: function (resolvedArgs) {\n      var joinChar = resolvedArgs[0];\n      var listJoin = resolvedArgs[1];\n      return listJoin.join(joinChar);\n    },\n    _functionToArray: function (resolvedArgs) {\n      if (this._getTypeName(resolvedArgs[0]) === TYPE_ARRAY) {\n        return resolvedArgs[0];\n      } else {\n        return [resolvedArgs[0]];\n      }\n    },\n    _functionToString: function (resolvedArgs) {\n      if (this._getTypeName(resolvedArgs[0]) === TYPE_STRING) {\n        return resolvedArgs[0];\n      } else {\n        return JSON.stringify(resolvedArgs[0]);\n      }\n    },\n    _functionToNumber: function (resolvedArgs) {\n      var typeName = this._getTypeName(resolvedArgs[0]);\n      var convertedValue;\n      if (typeName === TYPE_NUMBER) {\n        return resolvedArgs[0];\n      } else if (typeName === TYPE_STRING) {\n        convertedValue = +resolvedArgs[0];\n        if (!isNaN(convertedValue)) {\n          return convertedValue;\n        }\n      }\n      return null;\n    },\n    _functionNotNull: function (resolvedArgs) {\n      for (var i = 0; i < resolvedArgs.length; i++) {\n        if (this._getTypeName(resolvedArgs[i]) !== TYPE_NULL) {\n          return resolvedArgs[i];\n        }\n      }\n      return null;\n    },\n    _functionSort: function (resolvedArgs) {\n      var sortedArray = resolvedArgs[0].slice(0);\n      sortedArray.sort();\n      return sortedArray;\n    },\n    _functionSortBy: function (resolvedArgs) {\n      var sortedArray = resolvedArgs[0].slice(0);\n      if (sortedArray.length === 0) {\n        return sortedArray;\n      }\n      var interpreter = this._interpreter;\n      var exprefNode = resolvedArgs[1];\n      var requiredType = this._getTypeName(interpreter.visit(exprefNode, sortedArray[0]));\n      if ([TYPE_NUMBER, TYPE_STRING].indexOf(requiredType) < 0) {\n        throw new Error(\"TypeError\");\n      }\n      var that = this;\n      // In order to get a stable sort out of an unstable\n      // sort algorithm, we decorate/sort/undecorate (DSU)\n      // by creating a new list of [index, element] pairs.\n      // In the cmp function, if the evaluated elements are\n      // equal, then the index will be used as the tiebreaker.\n      // After the decorated list has been sorted, it will be\n      // undecorated to extract the original elements.\n      var decorated = [];\n      for (var i = 0; i < sortedArray.length; i++) {\n        decorated.push([i, sortedArray[i]]);\n      }\n      decorated.sort(function (a, b) {\n        var exprA = interpreter.visit(exprefNode, a[1]);\n        var exprB = interpreter.visit(exprefNode, b[1]);\n        if (that._getTypeName(exprA) !== requiredType) {\n          throw new Error(\"TypeError: expected \" + requiredType + \", received \" + that._getTypeName(exprA));\n        } else if (that._getTypeName(exprB) !== requiredType) {\n          throw new Error(\"TypeError: expected \" + requiredType + \", received \" + that._getTypeName(exprB));\n        }\n        if (exprA > exprB) {\n          return 1;\n        } else if (exprA < exprB) {\n          return -1;\n        } else {\n          // If they're equal compare the items by their\n          // order to maintain relative order of equal keys\n          // (i.e. to get a stable sort).\n          return a[0] - b[0];\n        }\n      });\n      // Undecorate: extract out the original list elements.\n      for (var j = 0; j < decorated.length; j++) {\n        sortedArray[j] = decorated[j][1];\n      }\n      return sortedArray;\n    },\n    _functionMaxBy: function (resolvedArgs) {\n      var exprefNode = resolvedArgs[1];\n      var resolvedArray = resolvedArgs[0];\n      var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);\n      var maxNumber = -Infinity;\n      var maxRecord;\n      var current;\n      for (var i = 0; i < resolvedArray.length; i++) {\n        current = keyFunction(resolvedArray[i]);\n        if (current > maxNumber) {\n          maxNumber = current;\n          maxRecord = resolvedArray[i];\n        }\n      }\n      return maxRecord;\n    },\n    _functionMinBy: function (resolvedArgs) {\n      var exprefNode = resolvedArgs[1];\n      var resolvedArray = resolvedArgs[0];\n      var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);\n      var minNumber = Infinity;\n      var minRecord;\n      var current;\n      for (var i = 0; i < resolvedArray.length; i++) {\n        current = keyFunction(resolvedArray[i]);\n        if (current < minNumber) {\n          minNumber = current;\n          minRecord = resolvedArray[i];\n        }\n      }\n      return minRecord;\n    },\n    createKeyFunction: function (exprefNode, allowedTypes) {\n      var that = this;\n      var interpreter = this._interpreter;\n      var keyFunc = function (x) {\n        var current = interpreter.visit(exprefNode, x);\n        if (allowedTypes.indexOf(that._getTypeName(current)) < 0) {\n          var msg = \"TypeError: expected one of \" + allowedTypes + \", received \" + that._getTypeName(current);\n          throw new Error(msg);\n        }\n        return current;\n      };\n      return keyFunc;\n    }\n  };\n  function compile(stream) {\n    var parser = new Parser();\n    var ast = parser.parse(stream);\n    return ast;\n  }\n  function tokenize(stream) {\n    var lexer = new Lexer();\n    return lexer.tokenize(stream);\n  }\n  function search(data, expression) {\n    var parser = new Parser();\n    // This needs to be improved.  Both the interpreter and runtime depend on\n    // each other.  The runtime needs the interpreter to support exprefs.\n    // There's likely a clean way to avoid the cyclic dependency.\n    var runtime = new Runtime();\n    var interpreter = new TreeInterpreter(runtime);\n    runtime._interpreter = interpreter;\n    var node = parser.parse(expression);\n    return interpreter.search(node, data);\n  }\n  exports.tokenize = tokenize;\n  exports.compile = compile;\n  exports.search = search;\n  exports.strictDeepEqual = strictDeepEqual;\n})(typeof exports === \"undefined\" ? this.jmespath = {} : exports);","map":{"version":3,"names":["exports","isArray","obj","Object","prototype","toString","call","isObject","strictDeepEqual","first","second","firstType","length","i","keysSeen","key","hasOwnProperty","key2","isFalse","objValues","keys","values","push","merge","a","b","merged","trimLeft","String","str","match","TYPE_NUMBER","TYPE_ANY","TYPE_STRING","TYPE_ARRAY","TYPE_OBJECT","TYPE_BOOLEAN","TYPE_EXPREF","TYPE_NULL","TYPE_ARRAY_NUMBER","TYPE_ARRAY_STRING","TYPE_NAME_TABLE","TOK_EOF","TOK_UNQUOTEDIDENTIFIER","TOK_QUOTEDIDENTIFIER","TOK_RBRACKET","TOK_RPAREN","TOK_COMMA","TOK_COLON","TOK_RBRACE","TOK_NUMBER","TOK_CURRENT","TOK_EXPREF","TOK_PIPE","TOK_OR","TOK_AND","TOK_EQ","TOK_GT","TOK_LT","TOK_GTE","TOK_LTE","TOK_NE","TOK_FLATTEN","TOK_STAR","TOK_FILTER","TOK_DOT","TOK_NOT","TOK_LBRACE","TOK_LBRACKET","TOK_LPAREN","TOK_LITERAL","basicTokens","operatorStartToken","skipChars","isAlpha","ch","isNum","isAlphaNum","Lexer","tokenize","stream","tokens","_current","start","identifier","token","_consumeUnquotedIdentifier","type","value","undefined","_consumeNumber","_consumeLBracket","_consumeQuotedIdentifier","_consumeRawStringLiteral","literal","_consumeLiteral","_consumeOperator","error","Error","name","slice","maxLength","current","JSON","parse","replace","parseInt","startingChar","literalString","_looksLikeJSON","startingChars","jsonLiterals","numberLooking","indexOf","ex","bindingPower","Parser","expression","_loadTokens","index","ast","_lookahead","t","_lookaheadToken","lexer","rbp","leftToken","_advance","left","nud","currentToken","led","number","right","node","Not","children","_parseProjectionRHS","Star","_parseMultiselectHash","Flatten","_parseIndexExpression","_projectIfSlice","_parseMultiselectList","Expref","args","_match","_errorToken","tokenName","Dot","_parseDotRHS","Pipe","Or","And","condition","Filter","leftNode","rightNode","_parseComparator","tokenType","_parseSliceExpression","indexExpr","parts","comparator","lookahead","exprTokens","expressions","pairs","identifierTypes","keyToken","keyName","TreeInterpreter","runtime","search","visit","matched","result","field","collected","sliceParams","computed","computeSliceParams","stop","step","base","filtered","finalResults","j","original","apply","child","resolvedArgs","callFunction","refNode","jmespathType","arrayLength","stepValueNegative","capSliceRange","actualValue","Runtime","interpreter","_interpreter","functionTable","abs","_func","_functionAbs","_signature","types","avg","_functionAvg","ceil","_functionCeil","contains","_functionContains","_functionEndsWith","floor","_functionFloor","_functionLength","map","_functionMap","max","_functionMax","_functionMerge","variadic","_functionMaxBy","sum","_functionSum","_functionStartsWith","min","_functionMin","_functionMinBy","_functionType","_functionKeys","_functionValues","sort","_functionSort","_functionSortBy","join","_functionJoin","reverse","_functionReverse","_functionToArray","_functionToString","_functionToNumber","_functionNotNull","functionEntry","_validateArgs","signature","pluralized","currentSpec","actualType","typeMatched","_getTypeName","_typeMatches","expected","typeIdentifier","actual","argValue","subtype","lastIndexOf","searchStr","suffix","typeName","originalStr","reversedStr","reversedArray","Math","inputArray","mapped","exprefNode","elements","maxElement","localeCompare","minElement","listToSum","joinChar","listJoin","stringify","convertedValue","isNaN","sortedArray","requiredType","that","decorated","exprA","exprB","resolvedArray","keyFunction","createKeyFunction","maxNumber","Infinity","maxRecord","minNumber","minRecord","allowedTypes","keyFunc","x","msg","compile","parser","data","jmespath"],"sources":["/Users/damianmiskow/Desktop/Projects/Synchrony-Interview-Process/node_modules/jmespath/jmespath.js"],"sourcesContent":["(function(exports) {\n  \"use strict\";\n\n  function isArray(obj) {\n    if (obj !== null) {\n      return Object.prototype.toString.call(obj) === \"[object Array]\";\n    } else {\n      return false;\n    }\n  }\n\n  function isObject(obj) {\n    if (obj !== null) {\n      return Object.prototype.toString.call(obj) === \"[object Object]\";\n    } else {\n      return false;\n    }\n  }\n\n  function strictDeepEqual(first, second) {\n    // Check the scalar case first.\n    if (first === second) {\n      return true;\n    }\n\n    // Check if they are the same type.\n    var firstType = Object.prototype.toString.call(first);\n    if (firstType !== Object.prototype.toString.call(second)) {\n      return false;\n    }\n    // We know that first and second have the same type so we can just check the\n    // first type from now on.\n    if (isArray(first) === true) {\n      // Short circuit if they're not the same length;\n      if (first.length !== second.length) {\n        return false;\n      }\n      for (var i = 0; i < first.length; i++) {\n        if (strictDeepEqual(first[i], second[i]) === false) {\n          return false;\n        }\n      }\n      return true;\n    }\n    if (isObject(first) === true) {\n      // An object is equal if it has the same key/value pairs.\n      var keysSeen = {};\n      for (var key in first) {\n        if (hasOwnProperty.call(first, key)) {\n          if (strictDeepEqual(first[key], second[key]) === false) {\n            return false;\n          }\n          keysSeen[key] = true;\n        }\n      }\n      // Now check that there aren't any keys in second that weren't\n      // in first.\n      for (var key2 in second) {\n        if (hasOwnProperty.call(second, key2)) {\n          if (keysSeen[key2] !== true) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n\n  function isFalse(obj) {\n    // From the spec:\n    // A false value corresponds to the following values:\n    // Empty list\n    // Empty object\n    // Empty string\n    // False boolean\n    // null value\n\n    // First check the scalar values.\n    if (obj === \"\" || obj === false || obj === null) {\n        return true;\n    } else if (isArray(obj) && obj.length === 0) {\n        // Check for an empty array.\n        return true;\n    } else if (isObject(obj)) {\n        // Check for an empty object.\n        for (var key in obj) {\n            // If there are any keys, then\n            // the object is not empty so the object\n            // is not false.\n            if (obj.hasOwnProperty(key)) {\n              return false;\n            }\n        }\n        return true;\n    } else {\n        return false;\n    }\n  }\n\n  function objValues(obj) {\n    var keys = Object.keys(obj);\n    var values = [];\n    for (var i = 0; i < keys.length; i++) {\n      values.push(obj[keys[i]]);\n    }\n    return values;\n  }\n\n  function merge(a, b) {\n      var merged = {};\n      for (var key in a) {\n          merged[key] = a[key];\n      }\n      for (var key2 in b) {\n          merged[key2] = b[key2];\n      }\n      return merged;\n  }\n\n  var trimLeft;\n  if (typeof String.prototype.trimLeft === \"function\") {\n    trimLeft = function(str) {\n      return str.trimLeft();\n    };\n  } else {\n    trimLeft = function(str) {\n      return str.match(/^\\s*(.*)/)[1];\n    };\n  }\n\n  // Type constants used to define functions.\n  var TYPE_NUMBER = 0;\n  var TYPE_ANY = 1;\n  var TYPE_STRING = 2;\n  var TYPE_ARRAY = 3;\n  var TYPE_OBJECT = 4;\n  var TYPE_BOOLEAN = 5;\n  var TYPE_EXPREF = 6;\n  var TYPE_NULL = 7;\n  var TYPE_ARRAY_NUMBER = 8;\n  var TYPE_ARRAY_STRING = 9;\n  var TYPE_NAME_TABLE = {\n    0: 'number',\n    1: 'any',\n    2: 'string',\n    3: 'array',\n    4: 'object',\n    5: 'boolean',\n    6: 'expression',\n    7: 'null',\n    8: 'Array<number>',\n    9: 'Array<string>'\n  };\n\n  var TOK_EOF = \"EOF\";\n  var TOK_UNQUOTEDIDENTIFIER = \"UnquotedIdentifier\";\n  var TOK_QUOTEDIDENTIFIER = \"QuotedIdentifier\";\n  var TOK_RBRACKET = \"Rbracket\";\n  var TOK_RPAREN = \"Rparen\";\n  var TOK_COMMA = \"Comma\";\n  var TOK_COLON = \"Colon\";\n  var TOK_RBRACE = \"Rbrace\";\n  var TOK_NUMBER = \"Number\";\n  var TOK_CURRENT = \"Current\";\n  var TOK_EXPREF = \"Expref\";\n  var TOK_PIPE = \"Pipe\";\n  var TOK_OR = \"Or\";\n  var TOK_AND = \"And\";\n  var TOK_EQ = \"EQ\";\n  var TOK_GT = \"GT\";\n  var TOK_LT = \"LT\";\n  var TOK_GTE = \"GTE\";\n  var TOK_LTE = \"LTE\";\n  var TOK_NE = \"NE\";\n  var TOK_FLATTEN = \"Flatten\";\n  var TOK_STAR = \"Star\";\n  var TOK_FILTER = \"Filter\";\n  var TOK_DOT = \"Dot\";\n  var TOK_NOT = \"Not\";\n  var TOK_LBRACE = \"Lbrace\";\n  var TOK_LBRACKET = \"Lbracket\";\n  var TOK_LPAREN= \"Lparen\";\n  var TOK_LITERAL= \"Literal\";\n\n  // The \"&\", \"[\", \"<\", \">\" tokens\n  // are not in basicToken because\n  // there are two token variants\n  // (\"&&\", \"[?\", \"<=\", \">=\").  This is specially handled\n  // below.\n\n  var basicTokens = {\n    \".\": TOK_DOT,\n    \"*\": TOK_STAR,\n    \",\": TOK_COMMA,\n    \":\": TOK_COLON,\n    \"{\": TOK_LBRACE,\n    \"}\": TOK_RBRACE,\n    \"]\": TOK_RBRACKET,\n    \"(\": TOK_LPAREN,\n    \")\": TOK_RPAREN,\n    \"@\": TOK_CURRENT\n  };\n\n  var operatorStartToken = {\n      \"<\": true,\n      \">\": true,\n      \"=\": true,\n      \"!\": true\n  };\n\n  var skipChars = {\n      \" \": true,\n      \"\\t\": true,\n      \"\\n\": true\n  };\n\n\n  function isAlpha(ch) {\n      return (ch >= \"a\" && ch <= \"z\") ||\n             (ch >= \"A\" && ch <= \"Z\") ||\n             ch === \"_\";\n  }\n\n  function isNum(ch) {\n      return (ch >= \"0\" && ch <= \"9\") ||\n             ch === \"-\";\n  }\n  function isAlphaNum(ch) {\n      return (ch >= \"a\" && ch <= \"z\") ||\n             (ch >= \"A\" && ch <= \"Z\") ||\n             (ch >= \"0\" && ch <= \"9\") ||\n             ch === \"_\";\n  }\n\n  function Lexer() {\n  }\n  Lexer.prototype = {\n      tokenize: function(stream) {\n          var tokens = [];\n          this._current = 0;\n          var start;\n          var identifier;\n          var token;\n          while (this._current < stream.length) {\n              if (isAlpha(stream[this._current])) {\n                  start = this._current;\n                  identifier = this._consumeUnquotedIdentifier(stream);\n                  tokens.push({type: TOK_UNQUOTEDIDENTIFIER,\n                               value: identifier,\n                               start: start});\n              } else if (basicTokens[stream[this._current]] !== undefined) {\n                  tokens.push({type: basicTokens[stream[this._current]],\n                              value: stream[this._current],\n                              start: this._current});\n                  this._current++;\n              } else if (isNum(stream[this._current])) {\n                  token = this._consumeNumber(stream);\n                  tokens.push(token);\n              } else if (stream[this._current] === \"[\") {\n                  // No need to increment this._current.  This happens\n                  // in _consumeLBracket\n                  token = this._consumeLBracket(stream);\n                  tokens.push(token);\n              } else if (stream[this._current] === \"\\\"\") {\n                  start = this._current;\n                  identifier = this._consumeQuotedIdentifier(stream);\n                  tokens.push({type: TOK_QUOTEDIDENTIFIER,\n                               value: identifier,\n                               start: start});\n              } else if (stream[this._current] === \"'\") {\n                  start = this._current;\n                  identifier = this._consumeRawStringLiteral(stream);\n                  tokens.push({type: TOK_LITERAL,\n                               value: identifier,\n                               start: start});\n              } else if (stream[this._current] === \"`\") {\n                  start = this._current;\n                  var literal = this._consumeLiteral(stream);\n                  tokens.push({type: TOK_LITERAL,\n                               value: literal,\n                               start: start});\n              } else if (operatorStartToken[stream[this._current]] !== undefined) {\n                  tokens.push(this._consumeOperator(stream));\n              } else if (skipChars[stream[this._current]] !== undefined) {\n                  // Ignore whitespace.\n                  this._current++;\n              } else if (stream[this._current] === \"&\") {\n                  start = this._current;\n                  this._current++;\n                  if (stream[this._current] === \"&\") {\n                      this._current++;\n                      tokens.push({type: TOK_AND, value: \"&&\", start: start});\n                  } else {\n                      tokens.push({type: TOK_EXPREF, value: \"&\", start: start});\n                  }\n              } else if (stream[this._current] === \"|\") {\n                  start = this._current;\n                  this._current++;\n                  if (stream[this._current] === \"|\") {\n                      this._current++;\n                      tokens.push({type: TOK_OR, value: \"||\", start: start});\n                  } else {\n                      tokens.push({type: TOK_PIPE, value: \"|\", start: start});\n                  }\n              } else {\n                  var error = new Error(\"Unknown character:\" + stream[this._current]);\n                  error.name = \"LexerError\";\n                  throw error;\n              }\n          }\n          return tokens;\n      },\n\n      _consumeUnquotedIdentifier: function(stream) {\n          var start = this._current;\n          this._current++;\n          while (this._current < stream.length && isAlphaNum(stream[this._current])) {\n              this._current++;\n          }\n          return stream.slice(start, this._current);\n      },\n\n      _consumeQuotedIdentifier: function(stream) {\n          var start = this._current;\n          this._current++;\n          var maxLength = stream.length;\n          while (stream[this._current] !== \"\\\"\" && this._current < maxLength) {\n              // You can escape a double quote and you can escape an escape.\n              var current = this._current;\n              if (stream[current] === \"\\\\\" && (stream[current + 1] === \"\\\\\" ||\n                                               stream[current + 1] === \"\\\"\")) {\n                  current += 2;\n              } else {\n                  current++;\n              }\n              this._current = current;\n          }\n          this._current++;\n          return JSON.parse(stream.slice(start, this._current));\n      },\n\n      _consumeRawStringLiteral: function(stream) {\n          var start = this._current;\n          this._current++;\n          var maxLength = stream.length;\n          while (stream[this._current] !== \"'\" && this._current < maxLength) {\n              // You can escape a single quote and you can escape an escape.\n              var current = this._current;\n              if (stream[current] === \"\\\\\" && (stream[current + 1] === \"\\\\\" ||\n                                               stream[current + 1] === \"'\")) {\n                  current += 2;\n              } else {\n                  current++;\n              }\n              this._current = current;\n          }\n          this._current++;\n          var literal = stream.slice(start + 1, this._current - 1);\n          return literal.replace(\"\\\\'\", \"'\");\n      },\n\n      _consumeNumber: function(stream) {\n          var start = this._current;\n          this._current++;\n          var maxLength = stream.length;\n          while (isNum(stream[this._current]) && this._current < maxLength) {\n              this._current++;\n          }\n          var value = parseInt(stream.slice(start, this._current));\n          return {type: TOK_NUMBER, value: value, start: start};\n      },\n\n      _consumeLBracket: function(stream) {\n          var start = this._current;\n          this._current++;\n          if (stream[this._current] === \"?\") {\n              this._current++;\n              return {type: TOK_FILTER, value: \"[?\", start: start};\n          } else if (stream[this._current] === \"]\") {\n              this._current++;\n              return {type: TOK_FLATTEN, value: \"[]\", start: start};\n          } else {\n              return {type: TOK_LBRACKET, value: \"[\", start: start};\n          }\n      },\n\n      _consumeOperator: function(stream) {\n          var start = this._current;\n          var startingChar = stream[start];\n          this._current++;\n          if (startingChar === \"!\") {\n              if (stream[this._current] === \"=\") {\n                  this._current++;\n                  return {type: TOK_NE, value: \"!=\", start: start};\n              } else {\n                return {type: TOK_NOT, value: \"!\", start: start};\n              }\n          } else if (startingChar === \"<\") {\n              if (stream[this._current] === \"=\") {\n                  this._current++;\n                  return {type: TOK_LTE, value: \"<=\", start: start};\n              } else {\n                  return {type: TOK_LT, value: \"<\", start: start};\n              }\n          } else if (startingChar === \">\") {\n              if (stream[this._current] === \"=\") {\n                  this._current++;\n                  return {type: TOK_GTE, value: \">=\", start: start};\n              } else {\n                  return {type: TOK_GT, value: \">\", start: start};\n              }\n          } else if (startingChar === \"=\") {\n              if (stream[this._current] === \"=\") {\n                  this._current++;\n                  return {type: TOK_EQ, value: \"==\", start: start};\n              }\n          }\n      },\n\n      _consumeLiteral: function(stream) {\n          this._current++;\n          var start = this._current;\n          var maxLength = stream.length;\n          var literal;\n          while(stream[this._current] !== \"`\" && this._current < maxLength) {\n              // You can escape a literal char or you can escape the escape.\n              var current = this._current;\n              if (stream[current] === \"\\\\\" && (stream[current + 1] === \"\\\\\" ||\n                                               stream[current + 1] === \"`\")) {\n                  current += 2;\n              } else {\n                  current++;\n              }\n              this._current = current;\n          }\n          var literalString = trimLeft(stream.slice(start, this._current));\n          literalString = literalString.replace(\"\\\\`\", \"`\");\n          if (this._looksLikeJSON(literalString)) {\n              literal = JSON.parse(literalString);\n          } else {\n              // Try to JSON parse it as \"<literal>\"\n              literal = JSON.parse(\"\\\"\" + literalString + \"\\\"\");\n          }\n          // +1 gets us to the ending \"`\", +1 to move on to the next char.\n          this._current++;\n          return literal;\n      },\n\n      _looksLikeJSON: function(literalString) {\n          var startingChars = \"[{\\\"\";\n          var jsonLiterals = [\"true\", \"false\", \"null\"];\n          var numberLooking = \"-0123456789\";\n\n          if (literalString === \"\") {\n              return false;\n          } else if (startingChars.indexOf(literalString[0]) >= 0) {\n              return true;\n          } else if (jsonLiterals.indexOf(literalString) >= 0) {\n              return true;\n          } else if (numberLooking.indexOf(literalString[0]) >= 0) {\n              try {\n                  JSON.parse(literalString);\n                  return true;\n              } catch (ex) {\n                  return false;\n              }\n          } else {\n              return false;\n          }\n      }\n  };\n\n      var bindingPower = {};\n      bindingPower[TOK_EOF] = 0;\n      bindingPower[TOK_UNQUOTEDIDENTIFIER] = 0;\n      bindingPower[TOK_QUOTEDIDENTIFIER] = 0;\n      bindingPower[TOK_RBRACKET] = 0;\n      bindingPower[TOK_RPAREN] = 0;\n      bindingPower[TOK_COMMA] = 0;\n      bindingPower[TOK_RBRACE] = 0;\n      bindingPower[TOK_NUMBER] = 0;\n      bindingPower[TOK_CURRENT] = 0;\n      bindingPower[TOK_EXPREF] = 0;\n      bindingPower[TOK_PIPE] = 1;\n      bindingPower[TOK_OR] = 2;\n      bindingPower[TOK_AND] = 3;\n      bindingPower[TOK_EQ] = 5;\n      bindingPower[TOK_GT] = 5;\n      bindingPower[TOK_LT] = 5;\n      bindingPower[TOK_GTE] = 5;\n      bindingPower[TOK_LTE] = 5;\n      bindingPower[TOK_NE] = 5;\n      bindingPower[TOK_FLATTEN] = 9;\n      bindingPower[TOK_STAR] = 20;\n      bindingPower[TOK_FILTER] = 21;\n      bindingPower[TOK_DOT] = 40;\n      bindingPower[TOK_NOT] = 45;\n      bindingPower[TOK_LBRACE] = 50;\n      bindingPower[TOK_LBRACKET] = 55;\n      bindingPower[TOK_LPAREN] = 60;\n\n  function Parser() {\n  }\n\n  Parser.prototype = {\n      parse: function(expression) {\n          this._loadTokens(expression);\n          this.index = 0;\n          var ast = this.expression(0);\n          if (this._lookahead(0) !== TOK_EOF) {\n              var t = this._lookaheadToken(0);\n              var error = new Error(\n                  \"Unexpected token type: \" + t.type + \", value: \" + t.value);\n              error.name = \"ParserError\";\n              throw error;\n          }\n          return ast;\n      },\n\n      _loadTokens: function(expression) {\n          var lexer = new Lexer();\n          var tokens = lexer.tokenize(expression);\n          tokens.push({type: TOK_EOF, value: \"\", start: expression.length});\n          this.tokens = tokens;\n      },\n\n      expression: function(rbp) {\n          var leftToken = this._lookaheadToken(0);\n          this._advance();\n          var left = this.nud(leftToken);\n          var currentToken = this._lookahead(0);\n          while (rbp < bindingPower[currentToken]) {\n              this._advance();\n              left = this.led(currentToken, left);\n              currentToken = this._lookahead(0);\n          }\n          return left;\n      },\n\n      _lookahead: function(number) {\n          return this.tokens[this.index + number].type;\n      },\n\n      _lookaheadToken: function(number) {\n          return this.tokens[this.index + number];\n      },\n\n      _advance: function() {\n          this.index++;\n      },\n\n      nud: function(token) {\n        var left;\n        var right;\n        var expression;\n        switch (token.type) {\n          case TOK_LITERAL:\n            return {type: \"Literal\", value: token.value};\n          case TOK_UNQUOTEDIDENTIFIER:\n            return {type: \"Field\", name: token.value};\n          case TOK_QUOTEDIDENTIFIER:\n            var node = {type: \"Field\", name: token.value};\n            if (this._lookahead(0) === TOK_LPAREN) {\n                throw new Error(\"Quoted identifier not allowed for function names.\");\n            }\n            return node;\n          case TOK_NOT:\n            right = this.expression(bindingPower.Not);\n            return {type: \"NotExpression\", children: [right]};\n          case TOK_STAR:\n            left = {type: \"Identity\"};\n            right = null;\n            if (this._lookahead(0) === TOK_RBRACKET) {\n                // This can happen in a multiselect,\n                // [a, b, *]\n                right = {type: \"Identity\"};\n            } else {\n                right = this._parseProjectionRHS(bindingPower.Star);\n            }\n            return {type: \"ValueProjection\", children: [left, right]};\n          case TOK_FILTER:\n            return this.led(token.type, {type: \"Identity\"});\n          case TOK_LBRACE:\n            return this._parseMultiselectHash();\n          case TOK_FLATTEN:\n            left = {type: TOK_FLATTEN, children: [{type: \"Identity\"}]};\n            right = this._parseProjectionRHS(bindingPower.Flatten);\n            return {type: \"Projection\", children: [left, right]};\n          case TOK_LBRACKET:\n            if (this._lookahead(0) === TOK_NUMBER || this._lookahead(0) === TOK_COLON) {\n                right = this._parseIndexExpression();\n                return this._projectIfSlice({type: \"Identity\"}, right);\n            } else if (this._lookahead(0) === TOK_STAR &&\n                       this._lookahead(1) === TOK_RBRACKET) {\n                this._advance();\n                this._advance();\n                right = this._parseProjectionRHS(bindingPower.Star);\n                return {type: \"Projection\",\n                        children: [{type: \"Identity\"}, right]};\n            }\n            return this._parseMultiselectList();\n          case TOK_CURRENT:\n            return {type: TOK_CURRENT};\n          case TOK_EXPREF:\n            expression = this.expression(bindingPower.Expref);\n            return {type: \"ExpressionReference\", children: [expression]};\n          case TOK_LPAREN:\n            var args = [];\n            while (this._lookahead(0) !== TOK_RPAREN) {\n              if (this._lookahead(0) === TOK_CURRENT) {\n                expression = {type: TOK_CURRENT};\n                this._advance();\n              } else {\n                expression = this.expression(0);\n              }\n              args.push(expression);\n            }\n            this._match(TOK_RPAREN);\n            return args[0];\n          default:\n            this._errorToken(token);\n        }\n      },\n\n      led: function(tokenName, left) {\n        var right;\n        switch(tokenName) {\n          case TOK_DOT:\n            var rbp = bindingPower.Dot;\n            if (this._lookahead(0) !== TOK_STAR) {\n                right = this._parseDotRHS(rbp);\n                return {type: \"Subexpression\", children: [left, right]};\n            }\n            // Creating a projection.\n            this._advance();\n            right = this._parseProjectionRHS(rbp);\n            return {type: \"ValueProjection\", children: [left, right]};\n          case TOK_PIPE:\n            right = this.expression(bindingPower.Pipe);\n            return {type: TOK_PIPE, children: [left, right]};\n          case TOK_OR:\n            right = this.expression(bindingPower.Or);\n            return {type: \"OrExpression\", children: [left, right]};\n          case TOK_AND:\n            right = this.expression(bindingPower.And);\n            return {type: \"AndExpression\", children: [left, right]};\n          case TOK_LPAREN:\n            var name = left.name;\n            var args = [];\n            var expression, node;\n            while (this._lookahead(0) !== TOK_RPAREN) {\n              if (this._lookahead(0) === TOK_CURRENT) {\n                expression = {type: TOK_CURRENT};\n                this._advance();\n              } else {\n                expression = this.expression(0);\n              }\n              if (this._lookahead(0) === TOK_COMMA) {\n                this._match(TOK_COMMA);\n              }\n              args.push(expression);\n            }\n            this._match(TOK_RPAREN);\n            node = {type: \"Function\", name: name, children: args};\n            return node;\n          case TOK_FILTER:\n            var condition = this.expression(0);\n            this._match(TOK_RBRACKET);\n            if (this._lookahead(0) === TOK_FLATTEN) {\n              right = {type: \"Identity\"};\n            } else {\n              right = this._parseProjectionRHS(bindingPower.Filter);\n            }\n            return {type: \"FilterProjection\", children: [left, right, condition]};\n          case TOK_FLATTEN:\n            var leftNode = {type: TOK_FLATTEN, children: [left]};\n            var rightNode = this._parseProjectionRHS(bindingPower.Flatten);\n            return {type: \"Projection\", children: [leftNode, rightNode]};\n          case TOK_EQ:\n          case TOK_NE:\n          case TOK_GT:\n          case TOK_GTE:\n          case TOK_LT:\n          case TOK_LTE:\n            return this._parseComparator(left, tokenName);\n          case TOK_LBRACKET:\n            var token = this._lookaheadToken(0);\n            if (token.type === TOK_NUMBER || token.type === TOK_COLON) {\n                right = this._parseIndexExpression();\n                return this._projectIfSlice(left, right);\n            }\n            this._match(TOK_STAR);\n            this._match(TOK_RBRACKET);\n            right = this._parseProjectionRHS(bindingPower.Star);\n            return {type: \"Projection\", children: [left, right]};\n          default:\n            this._errorToken(this._lookaheadToken(0));\n        }\n      },\n\n      _match: function(tokenType) {\n          if (this._lookahead(0) === tokenType) {\n              this._advance();\n          } else {\n              var t = this._lookaheadToken(0);\n              var error = new Error(\"Expected \" + tokenType + \", got: \" + t.type);\n              error.name = \"ParserError\";\n              throw error;\n          }\n      },\n\n      _errorToken: function(token) {\n          var error = new Error(\"Invalid token (\" +\n                                token.type + \"): \\\"\" +\n                                token.value + \"\\\"\");\n          error.name = \"ParserError\";\n          throw error;\n      },\n\n\n      _parseIndexExpression: function() {\n          if (this._lookahead(0) === TOK_COLON || this._lookahead(1) === TOK_COLON) {\n              return this._parseSliceExpression();\n          } else {\n              var node = {\n                  type: \"Index\",\n                  value: this._lookaheadToken(0).value};\n              this._advance();\n              this._match(TOK_RBRACKET);\n              return node;\n          }\n      },\n\n      _projectIfSlice: function(left, right) {\n          var indexExpr = {type: \"IndexExpression\", children: [left, right]};\n          if (right.type === \"Slice\") {\n              return {\n                  type: \"Projection\",\n                  children: [indexExpr, this._parseProjectionRHS(bindingPower.Star)]\n              };\n          } else {\n              return indexExpr;\n          }\n      },\n\n      _parseSliceExpression: function() {\n          // [start:end:step] where each part is optional, as well as the last\n          // colon.\n          var parts = [null, null, null];\n          var index = 0;\n          var currentToken = this._lookahead(0);\n          while (currentToken !== TOK_RBRACKET && index < 3) {\n              if (currentToken === TOK_COLON) {\n                  index++;\n                  this._advance();\n              } else if (currentToken === TOK_NUMBER) {\n                  parts[index] = this._lookaheadToken(0).value;\n                  this._advance();\n              } else {\n                  var t = this._lookahead(0);\n                  var error = new Error(\"Syntax error, unexpected token: \" +\n                                        t.value + \"(\" + t.type + \")\");\n                  error.name = \"Parsererror\";\n                  throw error;\n              }\n              currentToken = this._lookahead(0);\n          }\n          this._match(TOK_RBRACKET);\n          return {\n              type: \"Slice\",\n              children: parts\n          };\n      },\n\n      _parseComparator: function(left, comparator) {\n        var right = this.expression(bindingPower[comparator]);\n        return {type: \"Comparator\", name: comparator, children: [left, right]};\n      },\n\n      _parseDotRHS: function(rbp) {\n          var lookahead = this._lookahead(0);\n          var exprTokens = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER, TOK_STAR];\n          if (exprTokens.indexOf(lookahead) >= 0) {\n              return this.expression(rbp);\n          } else if (lookahead === TOK_LBRACKET) {\n              this._match(TOK_LBRACKET);\n              return this._parseMultiselectList();\n          } else if (lookahead === TOK_LBRACE) {\n              this._match(TOK_LBRACE);\n              return this._parseMultiselectHash();\n          }\n      },\n\n      _parseProjectionRHS: function(rbp) {\n          var right;\n          if (bindingPower[this._lookahead(0)] < 10) {\n              right = {type: \"Identity\"};\n          } else if (this._lookahead(0) === TOK_LBRACKET) {\n              right = this.expression(rbp);\n          } else if (this._lookahead(0) === TOK_FILTER) {\n              right = this.expression(rbp);\n          } else if (this._lookahead(0) === TOK_DOT) {\n              this._match(TOK_DOT);\n              right = this._parseDotRHS(rbp);\n          } else {\n              var t = this._lookaheadToken(0);\n              var error = new Error(\"Sytanx error, unexpected token: \" +\n                                    t.value + \"(\" + t.type + \")\");\n              error.name = \"ParserError\";\n              throw error;\n          }\n          return right;\n      },\n\n      _parseMultiselectList: function() {\n          var expressions = [];\n          while (this._lookahead(0) !== TOK_RBRACKET) {\n              var expression = this.expression(0);\n              expressions.push(expression);\n              if (this._lookahead(0) === TOK_COMMA) {\n                  this._match(TOK_COMMA);\n                  if (this._lookahead(0) === TOK_RBRACKET) {\n                    throw new Error(\"Unexpected token Rbracket\");\n                  }\n              }\n          }\n          this._match(TOK_RBRACKET);\n          return {type: \"MultiSelectList\", children: expressions};\n      },\n\n      _parseMultiselectHash: function() {\n        var pairs = [];\n        var identifierTypes = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER];\n        var keyToken, keyName, value, node;\n        for (;;) {\n          keyToken = this._lookaheadToken(0);\n          if (identifierTypes.indexOf(keyToken.type) < 0) {\n            throw new Error(\"Expecting an identifier token, got: \" +\n                            keyToken.type);\n          }\n          keyName = keyToken.value;\n          this._advance();\n          this._match(TOK_COLON);\n          value = this.expression(0);\n          node = {type: \"KeyValuePair\", name: keyName, value: value};\n          pairs.push(node);\n          if (this._lookahead(0) === TOK_COMMA) {\n            this._match(TOK_COMMA);\n          } else if (this._lookahead(0) === TOK_RBRACE) {\n            this._match(TOK_RBRACE);\n            break;\n          }\n        }\n        return {type: \"MultiSelectHash\", children: pairs};\n      }\n  };\n\n\n  function TreeInterpreter(runtime) {\n    this.runtime = runtime;\n  }\n\n  TreeInterpreter.prototype = {\n      search: function(node, value) {\n          return this.visit(node, value);\n      },\n\n      visit: function(node, value) {\n          var matched, current, result, first, second, field, left, right, collected, i;\n          switch (node.type) {\n            case \"Field\":\n              if (value !== null && isObject(value)) {\n                  field = value[node.name];\n                  if (field === undefined) {\n                      return null;\n                  } else {\n                      return field;\n                  }\n              }\n              return null;\n            case \"Subexpression\":\n              result = this.visit(node.children[0], value);\n              for (i = 1; i < node.children.length; i++) {\n                  result = this.visit(node.children[1], result);\n                  if (result === null) {\n                      return null;\n                  }\n              }\n              return result;\n            case \"IndexExpression\":\n              left = this.visit(node.children[0], value);\n              right = this.visit(node.children[1], left);\n              return right;\n            case \"Index\":\n              if (!isArray(value)) {\n                return null;\n              }\n              var index = node.value;\n              if (index < 0) {\n                index = value.length + index;\n              }\n              result = value[index];\n              if (result === undefined) {\n                result = null;\n              }\n              return result;\n            case \"Slice\":\n              if (!isArray(value)) {\n                return null;\n              }\n              var sliceParams = node.children.slice(0);\n              var computed = this.computeSliceParams(value.length, sliceParams);\n              var start = computed[0];\n              var stop = computed[1];\n              var step = computed[2];\n              result = [];\n              if (step > 0) {\n                  for (i = start; i < stop; i += step) {\n                      result.push(value[i]);\n                  }\n              } else {\n                  for (i = start; i > stop; i += step) {\n                      result.push(value[i]);\n                  }\n              }\n              return result;\n            case \"Projection\":\n              // Evaluate left child.\n              var base = this.visit(node.children[0], value);\n              if (!isArray(base)) {\n                return null;\n              }\n              collected = [];\n              for (i = 0; i < base.length; i++) {\n                current = this.visit(node.children[1], base[i]);\n                if (current !== null) {\n                  collected.push(current);\n                }\n              }\n              return collected;\n            case \"ValueProjection\":\n              // Evaluate left child.\n              base = this.visit(node.children[0], value);\n              if (!isObject(base)) {\n                return null;\n              }\n              collected = [];\n              var values = objValues(base);\n              for (i = 0; i < values.length; i++) {\n                current = this.visit(node.children[1], values[i]);\n                if (current !== null) {\n                  collected.push(current);\n                }\n              }\n              return collected;\n            case \"FilterProjection\":\n              base = this.visit(node.children[0], value);\n              if (!isArray(base)) {\n                return null;\n              }\n              var filtered = [];\n              var finalResults = [];\n              for (i = 0; i < base.length; i++) {\n                matched = this.visit(node.children[2], base[i]);\n                if (!isFalse(matched)) {\n                  filtered.push(base[i]);\n                }\n              }\n              for (var j = 0; j < filtered.length; j++) {\n                current = this.visit(node.children[1], filtered[j]);\n                if (current !== null) {\n                  finalResults.push(current);\n                }\n              }\n              return finalResults;\n            case \"Comparator\":\n              first = this.visit(node.children[0], value);\n              second = this.visit(node.children[1], value);\n              switch(node.name) {\n                case TOK_EQ:\n                  result = strictDeepEqual(first, second);\n                  break;\n                case TOK_NE:\n                  result = !strictDeepEqual(first, second);\n                  break;\n                case TOK_GT:\n                  result = first > second;\n                  break;\n                case TOK_GTE:\n                  result = first >= second;\n                  break;\n                case TOK_LT:\n                  result = first < second;\n                  break;\n                case TOK_LTE:\n                  result = first <= second;\n                  break;\n                default:\n                  throw new Error(\"Unknown comparator: \" + node.name);\n              }\n              return result;\n            case TOK_FLATTEN:\n              var original = this.visit(node.children[0], value);\n              if (!isArray(original)) {\n                return null;\n              }\n              var merged = [];\n              for (i = 0; i < original.length; i++) {\n                current = original[i];\n                if (isArray(current)) {\n                  merged.push.apply(merged, current);\n                } else {\n                  merged.push(current);\n                }\n              }\n              return merged;\n            case \"Identity\":\n              return value;\n            case \"MultiSelectList\":\n              if (value === null) {\n                return null;\n              }\n              collected = [];\n              for (i = 0; i < node.children.length; i++) {\n                  collected.push(this.visit(node.children[i], value));\n              }\n              return collected;\n            case \"MultiSelectHash\":\n              if (value === null) {\n                return null;\n              }\n              collected = {};\n              var child;\n              for (i = 0; i < node.children.length; i++) {\n                child = node.children[i];\n                collected[child.name] = this.visit(child.value, value);\n              }\n              return collected;\n            case \"OrExpression\":\n              matched = this.visit(node.children[0], value);\n              if (isFalse(matched)) {\n                  matched = this.visit(node.children[1], value);\n              }\n              return matched;\n            case \"AndExpression\":\n              first = this.visit(node.children[0], value);\n\n              if (isFalse(first) === true) {\n                return first;\n              }\n              return this.visit(node.children[1], value);\n            case \"NotExpression\":\n              first = this.visit(node.children[0], value);\n              return isFalse(first);\n            case \"Literal\":\n              return node.value;\n            case TOK_PIPE:\n              left = this.visit(node.children[0], value);\n              return this.visit(node.children[1], left);\n            case TOK_CURRENT:\n              return value;\n            case \"Function\":\n              var resolvedArgs = [];\n              for (i = 0; i < node.children.length; i++) {\n                  resolvedArgs.push(this.visit(node.children[i], value));\n              }\n              return this.runtime.callFunction(node.name, resolvedArgs);\n            case \"ExpressionReference\":\n              var refNode = node.children[0];\n              // Tag the node with a specific attribute so the type\n              // checker verify the type.\n              refNode.jmespathType = TOK_EXPREF;\n              return refNode;\n            default:\n              throw new Error(\"Unknown node type: \" + node.type);\n          }\n      },\n\n      computeSliceParams: function(arrayLength, sliceParams) {\n        var start = sliceParams[0];\n        var stop = sliceParams[1];\n        var step = sliceParams[2];\n        var computed = [null, null, null];\n        if (step === null) {\n          step = 1;\n        } else if (step === 0) {\n          var error = new Error(\"Invalid slice, step cannot be 0\");\n          error.name = \"RuntimeError\";\n          throw error;\n        }\n        var stepValueNegative = step < 0 ? true : false;\n\n        if (start === null) {\n            start = stepValueNegative ? arrayLength - 1 : 0;\n        } else {\n            start = this.capSliceRange(arrayLength, start, step);\n        }\n\n        if (stop === null) {\n            stop = stepValueNegative ? -1 : arrayLength;\n        } else {\n            stop = this.capSliceRange(arrayLength, stop, step);\n        }\n        computed[0] = start;\n        computed[1] = stop;\n        computed[2] = step;\n        return computed;\n      },\n\n      capSliceRange: function(arrayLength, actualValue, step) {\n          if (actualValue < 0) {\n              actualValue += arrayLength;\n              if (actualValue < 0) {\n                  actualValue = step < 0 ? -1 : 0;\n              }\n          } else if (actualValue >= arrayLength) {\n              actualValue = step < 0 ? arrayLength - 1 : arrayLength;\n          }\n          return actualValue;\n      }\n\n  };\n\n  function Runtime(interpreter) {\n    this._interpreter = interpreter;\n    this.functionTable = {\n        // name: [function, <signature>]\n        // The <signature> can be:\n        //\n        // {\n        //   args: [[type1, type2], [type1, type2]],\n        //   variadic: true|false\n        // }\n        //\n        // Each arg in the arg list is a list of valid types\n        // (if the function is overloaded and supports multiple\n        // types.  If the type is \"any\" then no type checking\n        // occurs on the argument.  Variadic is optional\n        // and if not provided is assumed to be false.\n        abs: {_func: this._functionAbs, _signature: [{types: [TYPE_NUMBER]}]},\n        avg: {_func: this._functionAvg, _signature: [{types: [TYPE_ARRAY_NUMBER]}]},\n        ceil: {_func: this._functionCeil, _signature: [{types: [TYPE_NUMBER]}]},\n        contains: {\n            _func: this._functionContains,\n            _signature: [{types: [TYPE_STRING, TYPE_ARRAY]},\n                        {types: [TYPE_ANY]}]},\n        \"ends_with\": {\n            _func: this._functionEndsWith,\n            _signature: [{types: [TYPE_STRING]}, {types: [TYPE_STRING]}]},\n        floor: {_func: this._functionFloor, _signature: [{types: [TYPE_NUMBER]}]},\n        length: {\n            _func: this._functionLength,\n            _signature: [{types: [TYPE_STRING, TYPE_ARRAY, TYPE_OBJECT]}]},\n        map: {\n            _func: this._functionMap,\n            _signature: [{types: [TYPE_EXPREF]}, {types: [TYPE_ARRAY]}]},\n        max: {\n            _func: this._functionMax,\n            _signature: [{types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]}]},\n        \"merge\": {\n            _func: this._functionMerge,\n            _signature: [{types: [TYPE_OBJECT], variadic: true}]\n        },\n        \"max_by\": {\n          _func: this._functionMaxBy,\n          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]\n        },\n        sum: {_func: this._functionSum, _signature: [{types: [TYPE_ARRAY_NUMBER]}]},\n        \"starts_with\": {\n            _func: this._functionStartsWith,\n            _signature: [{types: [TYPE_STRING]}, {types: [TYPE_STRING]}]},\n        min: {\n            _func: this._functionMin,\n            _signature: [{types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]}]},\n        \"min_by\": {\n          _func: this._functionMinBy,\n          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]\n        },\n        type: {_func: this._functionType, _signature: [{types: [TYPE_ANY]}]},\n        keys: {_func: this._functionKeys, _signature: [{types: [TYPE_OBJECT]}]},\n        values: {_func: this._functionValues, _signature: [{types: [TYPE_OBJECT]}]},\n        sort: {_func: this._functionSort, _signature: [{types: [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER]}]},\n        \"sort_by\": {\n          _func: this._functionSortBy,\n          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]\n        },\n        join: {\n            _func: this._functionJoin,\n            _signature: [\n                {types: [TYPE_STRING]},\n                {types: [TYPE_ARRAY_STRING]}\n            ]\n        },\n        reverse: {\n            _func: this._functionReverse,\n            _signature: [{types: [TYPE_STRING, TYPE_ARRAY]}]},\n        \"to_array\": {_func: this._functionToArray, _signature: [{types: [TYPE_ANY]}]},\n        \"to_string\": {_func: this._functionToString, _signature: [{types: [TYPE_ANY]}]},\n        \"to_number\": {_func: this._functionToNumber, _signature: [{types: [TYPE_ANY]}]},\n        \"not_null\": {\n            _func: this._functionNotNull,\n            _signature: [{types: [TYPE_ANY], variadic: true}]\n        }\n    };\n  }\n\n  Runtime.prototype = {\n    callFunction: function(name, resolvedArgs) {\n      var functionEntry = this.functionTable[name];\n      if (functionEntry === undefined) {\n          throw new Error(\"Unknown function: \" + name + \"()\");\n      }\n      this._validateArgs(name, resolvedArgs, functionEntry._signature);\n      return functionEntry._func.call(this, resolvedArgs);\n    },\n\n    _validateArgs: function(name, args, signature) {\n        // Validating the args requires validating\n        // the correct arity and the correct type of each arg.\n        // If the last argument is declared as variadic, then we need\n        // a minimum number of args to be required.  Otherwise it has to\n        // be an exact amount.\n        var pluralized;\n        if (signature[signature.length - 1].variadic) {\n            if (args.length < signature.length) {\n                pluralized = signature.length === 1 ? \" argument\" : \" arguments\";\n                throw new Error(\"ArgumentError: \" + name + \"() \" +\n                                \"takes at least\" + signature.length + pluralized +\n                                \" but received \" + args.length);\n            }\n        } else if (args.length !== signature.length) {\n            pluralized = signature.length === 1 ? \" argument\" : \" arguments\";\n            throw new Error(\"ArgumentError: \" + name + \"() \" +\n                            \"takes \" + signature.length + pluralized +\n                            \" but received \" + args.length);\n        }\n        var currentSpec;\n        var actualType;\n        var typeMatched;\n        for (var i = 0; i < signature.length; i++) {\n            typeMatched = false;\n            currentSpec = signature[i].types;\n            actualType = this._getTypeName(args[i]);\n            for (var j = 0; j < currentSpec.length; j++) {\n                if (this._typeMatches(actualType, currentSpec[j], args[i])) {\n                    typeMatched = true;\n                    break;\n                }\n            }\n            if (!typeMatched) {\n                var expected = currentSpec\n                    .map(function(typeIdentifier) {\n                        return TYPE_NAME_TABLE[typeIdentifier];\n                    })\n                    .join(',');\n                throw new Error(\"TypeError: \" + name + \"() \" +\n                                \"expected argument \" + (i + 1) +\n                                \" to be type \" + expected +\n                                \" but received type \" +\n                                TYPE_NAME_TABLE[actualType] + \" instead.\");\n            }\n        }\n    },\n\n    _typeMatches: function(actual, expected, argValue) {\n        if (expected === TYPE_ANY) {\n            return true;\n        }\n        if (expected === TYPE_ARRAY_STRING ||\n            expected === TYPE_ARRAY_NUMBER ||\n            expected === TYPE_ARRAY) {\n            // The expected type can either just be array,\n            // or it can require a specific subtype (array of numbers).\n            //\n            // The simplest case is if \"array\" with no subtype is specified.\n            if (expected === TYPE_ARRAY) {\n                return actual === TYPE_ARRAY;\n            } else if (actual === TYPE_ARRAY) {\n                // Otherwise we need to check subtypes.\n                // I think this has potential to be improved.\n                var subtype;\n                if (expected === TYPE_ARRAY_NUMBER) {\n                  subtype = TYPE_NUMBER;\n                } else if (expected === TYPE_ARRAY_STRING) {\n                  subtype = TYPE_STRING;\n                }\n                for (var i = 0; i < argValue.length; i++) {\n                    if (!this._typeMatches(\n                            this._getTypeName(argValue[i]), subtype,\n                                             argValue[i])) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        } else {\n            return actual === expected;\n        }\n    },\n    _getTypeName: function(obj) {\n        switch (Object.prototype.toString.call(obj)) {\n            case \"[object String]\":\n              return TYPE_STRING;\n            case \"[object Number]\":\n              return TYPE_NUMBER;\n            case \"[object Array]\":\n              return TYPE_ARRAY;\n            case \"[object Boolean]\":\n              return TYPE_BOOLEAN;\n            case \"[object Null]\":\n              return TYPE_NULL;\n            case \"[object Object]\":\n              // Check if it's an expref.  If it has, it's been\n              // tagged with a jmespathType attr of 'Expref';\n              if (obj.jmespathType === TOK_EXPREF) {\n                return TYPE_EXPREF;\n              } else {\n                return TYPE_OBJECT;\n              }\n        }\n    },\n\n    _functionStartsWith: function(resolvedArgs) {\n        return resolvedArgs[0].lastIndexOf(resolvedArgs[1]) === 0;\n    },\n\n    _functionEndsWith: function(resolvedArgs) {\n        var searchStr = resolvedArgs[0];\n        var suffix = resolvedArgs[1];\n        return searchStr.indexOf(suffix, searchStr.length - suffix.length) !== -1;\n    },\n\n    _functionReverse: function(resolvedArgs) {\n        var typeName = this._getTypeName(resolvedArgs[0]);\n        if (typeName === TYPE_STRING) {\n          var originalStr = resolvedArgs[0];\n          var reversedStr = \"\";\n          for (var i = originalStr.length - 1; i >= 0; i--) {\n              reversedStr += originalStr[i];\n          }\n          return reversedStr;\n        } else {\n          var reversedArray = resolvedArgs[0].slice(0);\n          reversedArray.reverse();\n          return reversedArray;\n        }\n    },\n\n    _functionAbs: function(resolvedArgs) {\n      return Math.abs(resolvedArgs[0]);\n    },\n\n    _functionCeil: function(resolvedArgs) {\n        return Math.ceil(resolvedArgs[0]);\n    },\n\n    _functionAvg: function(resolvedArgs) {\n        var sum = 0;\n        var inputArray = resolvedArgs[0];\n        for (var i = 0; i < inputArray.length; i++) {\n            sum += inputArray[i];\n        }\n        return sum / inputArray.length;\n    },\n\n    _functionContains: function(resolvedArgs) {\n        return resolvedArgs[0].indexOf(resolvedArgs[1]) >= 0;\n    },\n\n    _functionFloor: function(resolvedArgs) {\n        return Math.floor(resolvedArgs[0]);\n    },\n\n    _functionLength: function(resolvedArgs) {\n       if (!isObject(resolvedArgs[0])) {\n         return resolvedArgs[0].length;\n       } else {\n         // As far as I can tell, there's no way to get the length\n         // of an object without O(n) iteration through the object.\n         return Object.keys(resolvedArgs[0]).length;\n       }\n    },\n\n    _functionMap: function(resolvedArgs) {\n      var mapped = [];\n      var interpreter = this._interpreter;\n      var exprefNode = resolvedArgs[0];\n      var elements = resolvedArgs[1];\n      for (var i = 0; i < elements.length; i++) {\n          mapped.push(interpreter.visit(exprefNode, elements[i]));\n      }\n      return mapped;\n    },\n\n    _functionMerge: function(resolvedArgs) {\n      var merged = {};\n      for (var i = 0; i < resolvedArgs.length; i++) {\n        var current = resolvedArgs[i];\n        for (var key in current) {\n          merged[key] = current[key];\n        }\n      }\n      return merged;\n    },\n\n    _functionMax: function(resolvedArgs) {\n      if (resolvedArgs[0].length > 0) {\n        var typeName = this._getTypeName(resolvedArgs[0][0]);\n        if (typeName === TYPE_NUMBER) {\n          return Math.max.apply(Math, resolvedArgs[0]);\n        } else {\n          var elements = resolvedArgs[0];\n          var maxElement = elements[0];\n          for (var i = 1; i < elements.length; i++) {\n              if (maxElement.localeCompare(elements[i]) < 0) {\n                  maxElement = elements[i];\n              }\n          }\n          return maxElement;\n        }\n      } else {\n          return null;\n      }\n    },\n\n    _functionMin: function(resolvedArgs) {\n      if (resolvedArgs[0].length > 0) {\n        var typeName = this._getTypeName(resolvedArgs[0][0]);\n        if (typeName === TYPE_NUMBER) {\n          return Math.min.apply(Math, resolvedArgs[0]);\n        } else {\n          var elements = resolvedArgs[0];\n          var minElement = elements[0];\n          for (var i = 1; i < elements.length; i++) {\n              if (elements[i].localeCompare(minElement) < 0) {\n                  minElement = elements[i];\n              }\n          }\n          return minElement;\n        }\n      } else {\n        return null;\n      }\n    },\n\n    _functionSum: function(resolvedArgs) {\n      var sum = 0;\n      var listToSum = resolvedArgs[0];\n      for (var i = 0; i < listToSum.length; i++) {\n        sum += listToSum[i];\n      }\n      return sum;\n    },\n\n    _functionType: function(resolvedArgs) {\n        switch (this._getTypeName(resolvedArgs[0])) {\n          case TYPE_NUMBER:\n            return \"number\";\n          case TYPE_STRING:\n            return \"string\";\n          case TYPE_ARRAY:\n            return \"array\";\n          case TYPE_OBJECT:\n            return \"object\";\n          case TYPE_BOOLEAN:\n            return \"boolean\";\n          case TYPE_EXPREF:\n            return \"expref\";\n          case TYPE_NULL:\n            return \"null\";\n        }\n    },\n\n    _functionKeys: function(resolvedArgs) {\n        return Object.keys(resolvedArgs[0]);\n    },\n\n    _functionValues: function(resolvedArgs) {\n        var obj = resolvedArgs[0];\n        var keys = Object.keys(obj);\n        var values = [];\n        for (var i = 0; i < keys.length; i++) {\n            values.push(obj[keys[i]]);\n        }\n        return values;\n    },\n\n    _functionJoin: function(resolvedArgs) {\n        var joinChar = resolvedArgs[0];\n        var listJoin = resolvedArgs[1];\n        return listJoin.join(joinChar);\n    },\n\n    _functionToArray: function(resolvedArgs) {\n        if (this._getTypeName(resolvedArgs[0]) === TYPE_ARRAY) {\n            return resolvedArgs[0];\n        } else {\n            return [resolvedArgs[0]];\n        }\n    },\n\n    _functionToString: function(resolvedArgs) {\n        if (this._getTypeName(resolvedArgs[0]) === TYPE_STRING) {\n            return resolvedArgs[0];\n        } else {\n            return JSON.stringify(resolvedArgs[0]);\n        }\n    },\n\n    _functionToNumber: function(resolvedArgs) {\n        var typeName = this._getTypeName(resolvedArgs[0]);\n        var convertedValue;\n        if (typeName === TYPE_NUMBER) {\n            return resolvedArgs[0];\n        } else if (typeName === TYPE_STRING) {\n            convertedValue = +resolvedArgs[0];\n            if (!isNaN(convertedValue)) {\n                return convertedValue;\n            }\n        }\n        return null;\n    },\n\n    _functionNotNull: function(resolvedArgs) {\n        for (var i = 0; i < resolvedArgs.length; i++) {\n            if (this._getTypeName(resolvedArgs[i]) !== TYPE_NULL) {\n                return resolvedArgs[i];\n            }\n        }\n        return null;\n    },\n\n    _functionSort: function(resolvedArgs) {\n        var sortedArray = resolvedArgs[0].slice(0);\n        sortedArray.sort();\n        return sortedArray;\n    },\n\n    _functionSortBy: function(resolvedArgs) {\n        var sortedArray = resolvedArgs[0].slice(0);\n        if (sortedArray.length === 0) {\n            return sortedArray;\n        }\n        var interpreter = this._interpreter;\n        var exprefNode = resolvedArgs[1];\n        var requiredType = this._getTypeName(\n            interpreter.visit(exprefNode, sortedArray[0]));\n        if ([TYPE_NUMBER, TYPE_STRING].indexOf(requiredType) < 0) {\n            throw new Error(\"TypeError\");\n        }\n        var that = this;\n        // In order to get a stable sort out of an unstable\n        // sort algorithm, we decorate/sort/undecorate (DSU)\n        // by creating a new list of [index, element] pairs.\n        // In the cmp function, if the evaluated elements are\n        // equal, then the index will be used as the tiebreaker.\n        // After the decorated list has been sorted, it will be\n        // undecorated to extract the original elements.\n        var decorated = [];\n        for (var i = 0; i < sortedArray.length; i++) {\n          decorated.push([i, sortedArray[i]]);\n        }\n        decorated.sort(function(a, b) {\n          var exprA = interpreter.visit(exprefNode, a[1]);\n          var exprB = interpreter.visit(exprefNode, b[1]);\n          if (that._getTypeName(exprA) !== requiredType) {\n              throw new Error(\n                  \"TypeError: expected \" + requiredType + \", received \" +\n                  that._getTypeName(exprA));\n          } else if (that._getTypeName(exprB) !== requiredType) {\n              throw new Error(\n                  \"TypeError: expected \" + requiredType + \", received \" +\n                  that._getTypeName(exprB));\n          }\n          if (exprA > exprB) {\n            return 1;\n          } else if (exprA < exprB) {\n            return -1;\n          } else {\n            // If they're equal compare the items by their\n            // order to maintain relative order of equal keys\n            // (i.e. to get a stable sort).\n            return a[0] - b[0];\n          }\n        });\n        // Undecorate: extract out the original list elements.\n        for (var j = 0; j < decorated.length; j++) {\n          sortedArray[j] = decorated[j][1];\n        }\n        return sortedArray;\n    },\n\n    _functionMaxBy: function(resolvedArgs) {\n      var exprefNode = resolvedArgs[1];\n      var resolvedArray = resolvedArgs[0];\n      var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);\n      var maxNumber = -Infinity;\n      var maxRecord;\n      var current;\n      for (var i = 0; i < resolvedArray.length; i++) {\n        current = keyFunction(resolvedArray[i]);\n        if (current > maxNumber) {\n          maxNumber = current;\n          maxRecord = resolvedArray[i];\n        }\n      }\n      return maxRecord;\n    },\n\n    _functionMinBy: function(resolvedArgs) {\n      var exprefNode = resolvedArgs[1];\n      var resolvedArray = resolvedArgs[0];\n      var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);\n      var minNumber = Infinity;\n      var minRecord;\n      var current;\n      for (var i = 0; i < resolvedArray.length; i++) {\n        current = keyFunction(resolvedArray[i]);\n        if (current < minNumber) {\n          minNumber = current;\n          minRecord = resolvedArray[i];\n        }\n      }\n      return minRecord;\n    },\n\n    createKeyFunction: function(exprefNode, allowedTypes) {\n      var that = this;\n      var interpreter = this._interpreter;\n      var keyFunc = function(x) {\n        var current = interpreter.visit(exprefNode, x);\n        if (allowedTypes.indexOf(that._getTypeName(current)) < 0) {\n          var msg = \"TypeError: expected one of \" + allowedTypes +\n                    \", received \" + that._getTypeName(current);\n          throw new Error(msg);\n        }\n        return current;\n      };\n      return keyFunc;\n    }\n\n  };\n\n  function compile(stream) {\n    var parser = new Parser();\n    var ast = parser.parse(stream);\n    return ast;\n  }\n\n  function tokenize(stream) {\n      var lexer = new Lexer();\n      return lexer.tokenize(stream);\n  }\n\n  function search(data, expression) {\n      var parser = new Parser();\n      // This needs to be improved.  Both the interpreter and runtime depend on\n      // each other.  The runtime needs the interpreter to support exprefs.\n      // There's likely a clean way to avoid the cyclic dependency.\n      var runtime = new Runtime();\n      var interpreter = new TreeInterpreter(runtime);\n      runtime._interpreter = interpreter;\n      var node = parser.parse(expression);\n      return interpreter.search(node, data);\n  }\n\n  exports.tokenize = tokenize;\n  exports.compile = compile;\n  exports.search = search;\n  exports.strictDeepEqual = strictDeepEqual;\n})(typeof exports === \"undefined\" ? this.jmespath = {} : exports);\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}