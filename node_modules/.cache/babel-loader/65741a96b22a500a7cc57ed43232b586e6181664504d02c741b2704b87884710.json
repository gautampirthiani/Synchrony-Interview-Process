{"ast":null,"code":"var util = require('../util');\nvar Shape = require('../model/shape');\nfunction DomXmlParser() {}\nDomXmlParser.prototype.parse = function (xml, shape) {\n  if (xml.replace(/^\\s+/, '') === '') return {};\n  var result, error;\n  try {\n    if (window.DOMParser) {\n      try {\n        var parser = new DOMParser();\n        result = parser.parseFromString(xml, 'text/xml');\n      } catch (syntaxError) {\n        throw util.error(new Error('Parse error in document'), {\n          originalError: syntaxError,\n          code: 'XMLParserError',\n          retryable: true\n        });\n      }\n      if (result.documentElement === null) {\n        throw util.error(new Error('Cannot parse empty document.'), {\n          code: 'XMLParserError',\n          retryable: true\n        });\n      }\n      var isError = result.getElementsByTagName('parsererror')[0];\n      if (isError && (isError.parentNode === result || isError.parentNode.nodeName === 'body' || isError.parentNode.parentNode === result || isError.parentNode.parentNode.nodeName === 'body')) {\n        var errorElement = isError.getElementsByTagName('div')[0] || isError;\n        throw util.error(new Error(errorElement.textContent || 'Parser error in document'), {\n          code: 'XMLParserError',\n          retryable: true\n        });\n      }\n    } else if (window.ActiveXObject) {\n      result = new window.ActiveXObject('Microsoft.XMLDOM');\n      result.async = false;\n      if (!result.loadXML(xml)) {\n        throw util.error(new Error('Parse error in document'), {\n          code: 'XMLParserError',\n          retryable: true\n        });\n      }\n    } else {\n      throw new Error('Cannot load XML parser');\n    }\n  } catch (e) {\n    error = e;\n  }\n  if (result && result.documentElement && !error) {\n    var data = parseXml(result.documentElement, shape);\n    var metadata = getElementByTagName(result.documentElement, 'ResponseMetadata');\n    if (metadata) {\n      data.ResponseMetadata = parseXml(metadata, {});\n    }\n    return data;\n  } else if (error) {\n    throw util.error(error || new Error(), {\n      code: 'XMLParserError',\n      retryable: true\n    });\n  } else {\n    // empty xml document\n    return {};\n  }\n};\nfunction getElementByTagName(xml, tag) {\n  var elements = xml.getElementsByTagName(tag);\n  for (var i = 0, iLen = elements.length; i < iLen; i++) {\n    if (elements[i].parentNode === xml) {\n      return elements[i];\n    }\n  }\n}\nfunction parseXml(xml, shape) {\n  if (!shape) shape = {};\n  switch (shape.type) {\n    case 'structure':\n      return parseStructure(xml, shape);\n    case 'map':\n      return parseMap(xml, shape);\n    case 'list':\n      return parseList(xml, shape);\n    case undefined:\n    case null:\n      return parseUnknown(xml);\n    default:\n      return parseScalar(xml, shape);\n  }\n}\nfunction parseStructure(xml, shape) {\n  var data = {};\n  if (xml === null) return data;\n  util.each(shape.members, function (memberName, memberShape) {\n    if (memberShape.isXmlAttribute) {\n      if (Object.prototype.hasOwnProperty.call(xml.attributes, memberShape.name)) {\n        var value = xml.attributes[memberShape.name].value;\n        data[memberName] = parseXml({\n          textContent: value\n        }, memberShape);\n      }\n    } else {\n      var xmlChild = memberShape.flattened ? xml : getElementByTagName(xml, memberShape.name);\n      if (xmlChild) {\n        data[memberName] = parseXml(xmlChild, memberShape);\n      } else if (!memberShape.flattened && memberShape.type === 'list' && !shape.api.xmlNoDefaultLists) {\n        data[memberName] = memberShape.defaultValue;\n      }\n    }\n  });\n  return data;\n}\nfunction parseMap(xml, shape) {\n  var data = {};\n  var xmlKey = shape.key.name || 'key';\n  var xmlValue = shape.value.name || 'value';\n  var tagName = shape.flattened ? shape.name : 'entry';\n  var child = xml.firstElementChild;\n  while (child) {\n    if (child.nodeName === tagName) {\n      var key = getElementByTagName(child, xmlKey).textContent;\n      var value = getElementByTagName(child, xmlValue);\n      data[key] = parseXml(value, shape.value);\n    }\n    child = child.nextElementSibling;\n  }\n  return data;\n}\nfunction parseList(xml, shape) {\n  var data = [];\n  var tagName = shape.flattened ? shape.name : shape.member.name || 'member';\n  var child = xml.firstElementChild;\n  while (child) {\n    if (child.nodeName === tagName) {\n      data.push(parseXml(child, shape.member));\n    }\n    child = child.nextElementSibling;\n  }\n  return data;\n}\nfunction parseScalar(xml, shape) {\n  if (xml.getAttribute) {\n    var encoding = xml.getAttribute('encoding');\n    if (encoding === 'base64') {\n      shape = new Shape.create({\n        type: encoding\n      });\n    }\n  }\n  var text = xml.textContent;\n  if (text === '') text = null;\n  if (typeof shape.toType === 'function') {\n    return shape.toType(text);\n  } else {\n    return text;\n  }\n}\nfunction parseUnknown(xml) {\n  if (xml === undefined || xml === null) return '';\n\n  // empty object\n  if (!xml.firstElementChild) {\n    if (xml.parentNode.parentNode === null) return {};\n    if (xml.childNodes.length === 0) return '';else return xml.textContent;\n  }\n\n  // object, parse as structure\n  var shape = {\n    type: 'structure',\n    members: {}\n  };\n  var child = xml.firstElementChild;\n  while (child) {\n    var tag = child.nodeName;\n    if (Object.prototype.hasOwnProperty.call(shape.members, tag)) {\n      // multiple tags of the same name makes it a list\n      shape.members[tag].type = 'list';\n    } else {\n      shape.members[tag] = {\n        name: tag\n      };\n    }\n    child = child.nextElementSibling;\n  }\n  return parseStructure(xml, shape);\n}\n\n/**\n * @api private\n */\nmodule.exports = DomXmlParser;","map":{"version":3,"names":["util","require","Shape","DomXmlParser","prototype","parse","xml","shape","replace","result","error","window","DOMParser","parser","parseFromString","syntaxError","Error","originalError","code","retryable","documentElement","isError","getElementsByTagName","parentNode","nodeName","errorElement","textContent","ActiveXObject","async","loadXML","e","data","parseXml","metadata","getElementByTagName","ResponseMetadata","tag","elements","i","iLen","length","type","parseStructure","parseMap","parseList","undefined","parseUnknown","parseScalar","each","members","memberName","memberShape","isXmlAttribute","Object","hasOwnProperty","call","attributes","name","value","xmlChild","flattened","api","xmlNoDefaultLists","defaultValue","xmlKey","key","xmlValue","tagName","child","firstElementChild","nextElementSibling","member","push","getAttribute","encoding","create","text","toType","childNodes","module","exports"],"sources":["/Users/damianmiskow/Desktop/Projects/Synchrony-Interview-Process/node_modules/aws-sdk/lib/xml/browser_parser.js"],"sourcesContent":["var util = require('../util');\nvar Shape = require('../model/shape');\n\nfunction DomXmlParser() { }\n\nDomXmlParser.prototype.parse = function(xml, shape) {\n  if (xml.replace(/^\\s+/, '') === '') return {};\n\n  var result, error;\n  try {\n    if (window.DOMParser) {\n      try {\n        var parser = new DOMParser();\n        result = parser.parseFromString(xml, 'text/xml');\n      } catch (syntaxError) {\n        throw util.error(new Error('Parse error in document'),\n          {\n            originalError: syntaxError,\n            code: 'XMLParserError',\n            retryable: true\n          });\n      }\n\n      if (result.documentElement === null) {\n        throw util.error(new Error('Cannot parse empty document.'),\n          {\n            code: 'XMLParserError',\n            retryable: true\n          });\n      }\n\n      var isError = result.getElementsByTagName('parsererror')[0];\n      if (isError && (isError.parentNode === result ||\n          isError.parentNode.nodeName === 'body' ||\n          isError.parentNode.parentNode === result ||\n          isError.parentNode.parentNode.nodeName === 'body')) {\n        var errorElement = isError.getElementsByTagName('div')[0] || isError;\n        throw util.error(new Error(errorElement.textContent || 'Parser error in document'),\n          {\n            code: 'XMLParserError',\n            retryable: true\n          });\n      }\n    } else if (window.ActiveXObject) {\n      result = new window.ActiveXObject('Microsoft.XMLDOM');\n      result.async = false;\n\n      if (!result.loadXML(xml)) {\n        throw util.error(new Error('Parse error in document'),\n          {\n            code: 'XMLParserError',\n            retryable: true\n          });\n      }\n    } else {\n      throw new Error('Cannot load XML parser');\n    }\n  } catch (e) {\n    error = e;\n  }\n\n  if (result && result.documentElement && !error) {\n    var data = parseXml(result.documentElement, shape);\n    var metadata = getElementByTagName(result.documentElement, 'ResponseMetadata');\n    if (metadata) {\n      data.ResponseMetadata = parseXml(metadata, {});\n    }\n    return data;\n  } else if (error) {\n    throw util.error(error || new Error(), {code: 'XMLParserError', retryable: true});\n  } else { // empty xml document\n    return {};\n  }\n};\n\nfunction getElementByTagName(xml, tag) {\n  var elements = xml.getElementsByTagName(tag);\n  for (var i = 0, iLen = elements.length; i < iLen; i++) {\n    if (elements[i].parentNode === xml) {\n      return elements[i];\n    }\n  }\n}\n\nfunction parseXml(xml, shape) {\n  if (!shape) shape = {};\n  switch (shape.type) {\n    case 'structure': return parseStructure(xml, shape);\n    case 'map': return parseMap(xml, shape);\n    case 'list': return parseList(xml, shape);\n    case undefined: case null: return parseUnknown(xml);\n    default: return parseScalar(xml, shape);\n  }\n}\n\nfunction parseStructure(xml, shape) {\n  var data = {};\n  if (xml === null) return data;\n\n  util.each(shape.members, function(memberName, memberShape) {\n    if (memberShape.isXmlAttribute) {\n      if (Object.prototype.hasOwnProperty.call(xml.attributes, memberShape.name)) {\n        var value = xml.attributes[memberShape.name].value;\n        data[memberName] = parseXml({textContent: value}, memberShape);\n      }\n    } else {\n      var xmlChild = memberShape.flattened ? xml :\n        getElementByTagName(xml, memberShape.name);\n      if (xmlChild) {\n        data[memberName] = parseXml(xmlChild, memberShape);\n      } else if (\n        !memberShape.flattened &&\n        memberShape.type === 'list' &&\n        !shape.api.xmlNoDefaultLists) {\n        data[memberName] = memberShape.defaultValue;\n      }\n    }\n  });\n\n  return data;\n}\n\nfunction parseMap(xml, shape) {\n  var data = {};\n  var xmlKey = shape.key.name || 'key';\n  var xmlValue = shape.value.name || 'value';\n  var tagName = shape.flattened ? shape.name : 'entry';\n\n  var child = xml.firstElementChild;\n  while (child) {\n    if (child.nodeName === tagName) {\n      var key = getElementByTagName(child, xmlKey).textContent;\n      var value = getElementByTagName(child, xmlValue);\n      data[key] = parseXml(value, shape.value);\n    }\n    child = child.nextElementSibling;\n  }\n  return data;\n}\n\nfunction parseList(xml, shape) {\n  var data = [];\n  var tagName = shape.flattened ? shape.name : (shape.member.name || 'member');\n\n  var child = xml.firstElementChild;\n  while (child) {\n    if (child.nodeName === tagName) {\n      data.push(parseXml(child, shape.member));\n    }\n    child = child.nextElementSibling;\n  }\n  return data;\n}\n\nfunction parseScalar(xml, shape) {\n  if (xml.getAttribute) {\n    var encoding = xml.getAttribute('encoding');\n    if (encoding === 'base64') {\n      shape = new Shape.create({type: encoding});\n    }\n  }\n\n  var text = xml.textContent;\n  if (text === '') text = null;\n  if (typeof shape.toType === 'function') {\n    return shape.toType(text);\n  } else {\n    return text;\n  }\n}\n\nfunction parseUnknown(xml) {\n  if (xml === undefined || xml === null) return '';\n\n  // empty object\n  if (!xml.firstElementChild) {\n    if (xml.parentNode.parentNode === null) return {};\n    if (xml.childNodes.length === 0) return '';\n    else return xml.textContent;\n  }\n\n  // object, parse as structure\n  var shape = {type: 'structure', members: {}};\n  var child = xml.firstElementChild;\n  while (child) {\n    var tag = child.nodeName;\n    if (Object.prototype.hasOwnProperty.call(shape.members, tag)) {\n      // multiple tags of the same name makes it a list\n      shape.members[tag].type = 'list';\n    } else {\n      shape.members[tag] = {name: tag};\n    }\n    child = child.nextElementSibling;\n  }\n  return parseStructure(xml, shape);\n}\n\n/**\n * @api private\n */\nmodule.exports = DomXmlParser;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}