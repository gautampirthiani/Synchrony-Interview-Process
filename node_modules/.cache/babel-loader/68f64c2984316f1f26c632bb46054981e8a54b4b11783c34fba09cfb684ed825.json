{"ast":null,"code":"var parseMessage = require('./parse-message').parseMessage;\n\n/**\n *\n * @param {*} parser\n * @param {Buffer} message\n * @param {*} shape\n * @api private\n */\nfunction parseEvent(parser, message, shape) {\n  var parsedMessage = parseMessage(message);\n\n  // check if message is an event or error\n  var messageType = parsedMessage.headers[':message-type'];\n  if (messageType) {\n    if (messageType.value === 'error') {\n      throw parseError(parsedMessage);\n    } else if (messageType.value !== 'event') {\n      // not sure how to parse non-events/non-errors, ignore for now\n      return;\n    }\n  }\n\n  // determine event type\n  var eventType = parsedMessage.headers[':event-type'];\n  // check that the event type is modeled\n  var eventModel = shape.members[eventType.value];\n  if (!eventModel) {\n    return;\n  }\n  var result = {};\n  // check if an event payload exists\n  var eventPayloadMemberName = eventModel.eventPayloadMemberName;\n  if (eventPayloadMemberName) {\n    var payloadShape = eventModel.members[eventPayloadMemberName];\n    // if the shape is binary, return the byte array\n    if (payloadShape.type === 'binary') {\n      result[eventPayloadMemberName] = parsedMessage.body;\n    } else {\n      result[eventPayloadMemberName] = parser.parse(parsedMessage.body.toString(), payloadShape);\n    }\n  }\n\n  // read event headers\n  var eventHeaderNames = eventModel.eventHeaderMemberNames;\n  for (var i = 0; i < eventHeaderNames.length; i++) {\n    var name = eventHeaderNames[i];\n    if (parsedMessage.headers[name]) {\n      // parse the header!\n      result[name] = eventModel.members[name].toType(parsedMessage.headers[name].value);\n    }\n  }\n  var output = {};\n  output[eventType.value] = result;\n  return output;\n}\nfunction parseError(message) {\n  var errorCode = message.headers[':error-code'];\n  var errorMessage = message.headers[':error-message'];\n  var error = new Error(errorMessage.value || errorMessage);\n  error.code = error.name = errorCode.value || errorCode;\n  return error;\n}\n\n/**\n * @api private\n */\nmodule.exports = {\n  parseEvent: parseEvent\n};","map":{"version":3,"names":["parseMessage","require","parseEvent","parser","message","shape","parsedMessage","messageType","headers","value","parseError","eventType","eventModel","members","result","eventPayloadMemberName","payloadShape","type","body","parse","toString","eventHeaderNames","eventHeaderMemberNames","i","length","name","toType","output","errorCode","errorMessage","error","Error","code","module","exports"],"sources":["/Users/damianmiskow/Desktop/Projects/Synchrony-Interview-Process/node_modules/aws-sdk/lib/event-stream/parse-event.js"],"sourcesContent":["var parseMessage = require('./parse-message').parseMessage;\n\n/**\n *\n * @param {*} parser\n * @param {Buffer} message\n * @param {*} shape\n * @api private\n */\nfunction parseEvent(parser, message, shape) {\n    var parsedMessage = parseMessage(message);\n\n    // check if message is an event or error\n    var messageType = parsedMessage.headers[':message-type'];\n    if (messageType) {\n        if (messageType.value === 'error') {\n            throw parseError(parsedMessage);\n        } else if (messageType.value !== 'event') {\n            // not sure how to parse non-events/non-errors, ignore for now\n            return;\n        }\n    }\n\n    // determine event type\n    var eventType = parsedMessage.headers[':event-type'];\n    // check that the event type is modeled\n    var eventModel = shape.members[eventType.value];\n    if (!eventModel) {\n        return;\n    }\n\n    var result = {};\n    // check if an event payload exists\n    var eventPayloadMemberName = eventModel.eventPayloadMemberName;\n    if (eventPayloadMemberName) {\n        var payloadShape = eventModel.members[eventPayloadMemberName];\n        // if the shape is binary, return the byte array\n        if (payloadShape.type === 'binary') {\n            result[eventPayloadMemberName] = parsedMessage.body;\n        } else {\n            result[eventPayloadMemberName] = parser.parse(parsedMessage.body.toString(), payloadShape);\n        }\n    }\n\n    // read event headers\n    var eventHeaderNames = eventModel.eventHeaderMemberNames;\n    for (var i = 0; i < eventHeaderNames.length; i++) {\n        var name = eventHeaderNames[i];\n        if (parsedMessage.headers[name]) {\n            // parse the header!\n            result[name] = eventModel.members[name].toType(parsedMessage.headers[name].value);\n        }\n    }\n\n    var output = {};\n    output[eventType.value] = result;\n    return output;\n}\n\nfunction parseError(message) {\n    var errorCode = message.headers[':error-code'];\n    var errorMessage = message.headers[':error-message'];\n    var error = new Error(errorMessage.value || errorMessage);\n    error.code = error.name = errorCode.value || errorCode;\n    return error;\n}\n\n/**\n * @api private\n */\nmodule.exports = {\n    parseEvent: parseEvent\n};\n"],"mappings":"AAAA,IAAIA,YAAY,GAAGC,OAAO,CAAC,iBAAiB,CAAC,CAACD,YAAY;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,UAAUA,CAACC,MAAM,EAAEC,OAAO,EAAEC,KAAK,EAAE;EACxC,IAAIC,aAAa,GAAGN,YAAY,CAACI,OAAO,CAAC;;EAEzC;EACA,IAAIG,WAAW,GAAGD,aAAa,CAACE,OAAO,CAAC,eAAe,CAAC;EACxD,IAAID,WAAW,EAAE;IACb,IAAIA,WAAW,CAACE,KAAK,KAAK,OAAO,EAAE;MAC/B,MAAMC,UAAU,CAACJ,aAAa,CAAC;IACnC,CAAC,MAAM,IAAIC,WAAW,CAACE,KAAK,KAAK,OAAO,EAAE;MACtC;MACA;IACJ;EACJ;;EAEA;EACA,IAAIE,SAAS,GAAGL,aAAa,CAACE,OAAO,CAAC,aAAa,CAAC;EACpD;EACA,IAAII,UAAU,GAAGP,KAAK,CAACQ,OAAO,CAACF,SAAS,CAACF,KAAK,CAAC;EAC/C,IAAI,CAACG,UAAU,EAAE;IACb;EACJ;EAEA,IAAIE,MAAM,GAAG,CAAC,CAAC;EACf;EACA,IAAIC,sBAAsB,GAAGH,UAAU,CAACG,sBAAsB;EAC9D,IAAIA,sBAAsB,EAAE;IACxB,IAAIC,YAAY,GAAGJ,UAAU,CAACC,OAAO,CAACE,sBAAsB,CAAC;IAC7D;IACA,IAAIC,YAAY,CAACC,IAAI,KAAK,QAAQ,EAAE;MAChCH,MAAM,CAACC,sBAAsB,CAAC,GAAGT,aAAa,CAACY,IAAI;IACvD,CAAC,MAAM;MACHJ,MAAM,CAACC,sBAAsB,CAAC,GAAGZ,MAAM,CAACgB,KAAK,CAACb,aAAa,CAACY,IAAI,CAACE,QAAQ,CAAC,CAAC,EAAEJ,YAAY,CAAC;IAC9F;EACJ;;EAEA;EACA,IAAIK,gBAAgB,GAAGT,UAAU,CAACU,sBAAsB;EACxD,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,gBAAgB,CAACG,MAAM,EAAED,CAAC,EAAE,EAAE;IAC9C,IAAIE,IAAI,GAAGJ,gBAAgB,CAACE,CAAC,CAAC;IAC9B,IAAIjB,aAAa,CAACE,OAAO,CAACiB,IAAI,CAAC,EAAE;MAC7B;MACAX,MAAM,CAACW,IAAI,CAAC,GAAGb,UAAU,CAACC,OAAO,CAACY,IAAI,CAAC,CAACC,MAAM,CAACpB,aAAa,CAACE,OAAO,CAACiB,IAAI,CAAC,CAAChB,KAAK,CAAC;IACrF;EACJ;EAEA,IAAIkB,MAAM,GAAG,CAAC,CAAC;EACfA,MAAM,CAAChB,SAAS,CAACF,KAAK,CAAC,GAAGK,MAAM;EAChC,OAAOa,MAAM;AACjB;AAEA,SAASjB,UAAUA,CAACN,OAAO,EAAE;EACzB,IAAIwB,SAAS,GAAGxB,OAAO,CAACI,OAAO,CAAC,aAAa,CAAC;EAC9C,IAAIqB,YAAY,GAAGzB,OAAO,CAACI,OAAO,CAAC,gBAAgB,CAAC;EACpD,IAAIsB,KAAK,GAAG,IAAIC,KAAK,CAACF,YAAY,CAACpB,KAAK,IAAIoB,YAAY,CAAC;EACzDC,KAAK,CAACE,IAAI,GAAGF,KAAK,CAACL,IAAI,GAAGG,SAAS,CAACnB,KAAK,IAAImB,SAAS;EACtD,OAAOE,KAAK;AAChB;;AAEA;AACA;AACA;AACAG,MAAM,CAACC,OAAO,GAAG;EACbhC,UAAU,EAAEA;AAChB,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}